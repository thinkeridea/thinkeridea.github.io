<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thinkeridea博客</title>
  <icon>https://www.gravatar.com/avatar/9d6f60998913bb76135b4779bbb90154</icon>
  <subtitle>thinkeridea</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.thinkeridea.com/"/>
  <updated>2019-01-26T12:02:37.245Z</updated>
  <id>https://blog.thinkeridea.com/</id>
  
  <author>
    <name>戚银</name>
    <email>qiyin@thinkeridea.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Go】优雅的读取http请求或响应的数据</title>
    <link href="https://blog.thinkeridea.com/201901/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju.html"/>
    <id>https://blog.thinkeridea.com/201901/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju.html</id>
    <published>2019-01-26T12:02:37.245Z</published>
    <updated>2019-01-26T12:02:37.245Z</updated>
    
    <content type="html"><![CDATA[<p>从 <code>http.Request.Body</code> 或 <code>http.Response.Body</code> 中读取数据方法或许很多，标准库中大多数使用 <code>ioutil.ReadAll</code> 方法一次读取所有数据，如果是 <code>json</code> 格式的数据还可以使用 <code>json.NewDecoder</code> 从 <code>io.Reader</code> 创建一个解析器，假使使用 <code>pprof</code> 来分析程序总是会发现 <code>bytes.makeSlice</code> 分配了大量内存，且总是排行第一，今天就这个问题来说一下如何高效优雅的读取 <code>http</code> 中的数据。</p><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我们有许多 <code>api</code> 服务，全部采用 <code>json</code> 数据格式，请求体就是整个 <code>json</code> 字符串，当一个请求到服务端会经过一些业务处理，然后再请求后面更多的服务，所有的服务之间都用 <code>http</code> 协议来通信(啊， 为啥不用 <code>RPC</code>，因为所有的服务都会对第三方开放，<code>http</code> + <code>json</code> 更好对接)，大多数请求数据大小在 1K~4K，响应的数据在 1K~8K，早期所有的服务都使用 <code>ioutil.ReadAll</code> 来读取数据，随着流量增加使用 <code>pprof</code> 来分析发现 <code>bytes.makeSlice</code> 总是排在第一，并且占用了整个程序 <code>1/10</code> 的内存分配，我决定针对这个问题进行优化，下面是整个优化过程的记录。</p><h2 id="pprof-分析"><a href="#pprof-分析" class="headerlink" title="pprof 分析"></a>pprof 分析</h2><p>这里使用 <a href="https://github.com/thinkeridea/go-extend/blob/master/exnet/exhttp/expprof/pprof.go" target="_blank" rel="noopener">https://github.com/thinkeridea/go-extend/blob/master/exnet/exhttp/expprof/pprof.go</a> 中的 <code>API</code> 来实现生产环境的 <code>/debug/pprof</code> 监测接口，没有使用标准库的 <code>net/http/pprof</code> 包因为会自动注册路由，且长期开放 <code>API</code>，这个包可以设定 <code>API</code> 是否开放，并在规定时间后自动关闭接口，避免存在工具嗅探。</p><p>服务部署上线稳定后(大约过了一天半)，通过 <code>curl</code> 下载 <code>allocs</code> 数据，然后使用下面的命令查看分析。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof allocs</span><br><span class="line">File: xxx</span><br><span class="line">Type: alloc_space</span><br><span class="line">Time: Jan <span class="number">25</span>, <span class="number">2019</span> at <span class="number">3</span>:<span class="number">02</span>pm (CST)</span><br><span class="line">Entering interactive mode (type <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">604.62</span>GB, <span class="number">44.50</span>% of <span class="number">1358.61</span>GB total</span><br><span class="line">Dropped <span class="number">776</span> nodes (cum &lt;= <span class="number">6.79</span>GB)</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">155</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">111.40</span>GB  <span class="number">8.20</span>%  <span class="number">8.20</span>%   <span class="number">111.40</span>GB  <span class="number">8.20</span>%  bytes.makeSlice</span><br><span class="line">  <span class="number">107.72</span>GB  <span class="number">7.93</span>% <span class="number">16.13</span>%   <span class="number">107.72</span>GB  <span class="number">7.93</span>%  github.com/sirupsen/logrus.(*Entry).WithFields</span><br><span class="line">   <span class="number">65.94</span>GB  <span class="number">4.85</span>% <span class="number">20.98</span>%    <span class="number">65.94</span>GB  <span class="number">4.85</span>%  strings.Replace</span><br><span class="line">   <span class="number">54.10</span>GB  <span class="number">3.98</span>% <span class="number">24.96</span>%    <span class="number">56.03</span>GB  <span class="number">4.12</span>%  github.com/json-iterator/go.(*frozenConfig).Marshal</span><br><span class="line">   <span class="number">47.54</span>GB  <span class="number">3.50</span>% <span class="number">28.46</span>%    <span class="number">47.54</span>GB  <span class="number">3.50</span>%  net/url.unescape</span><br><span class="line">   <span class="number">47.11</span>GB  <span class="number">3.47</span>% <span class="number">31.93</span>%    <span class="number">48.16</span>GB  <span class="number">3.55</span>%  github.com/json-iterator/go.(*Iterator).readStringSlowPath</span><br><span class="line">   <span class="number">46.63</span>GB  <span class="number">3.43</span>% <span class="number">35.36</span>%   <span class="number">103.04</span>GB  <span class="number">7.58</span>%  handlers.(*AdserviceHandler).returnAd</span><br><span class="line">   <span class="number">42.43</span>GB  <span class="number">3.12</span>% <span class="number">38.49</span>%    <span class="number">84.62</span>GB  <span class="number">6.23</span>%  models.LogItemsToBytes</span><br><span class="line">   <span class="number">42.22</span>GB  <span class="number">3.11</span>% <span class="number">41.59</span>%    <span class="number">42.22</span>GB  <span class="number">3.11</span>%  strings.Join</span><br><span class="line">   <span class="number">39.52</span>GB  <span class="number">2.91</span>% <span class="number">44.50</span>%    <span class="number">87.06</span>GB  <span class="number">6.41</span>%  net/url.parseQuery</span><br></pre></td></tr></table></figure><p>从结果中可以看出采集期间一共分配了 <code>1358.61GB</code> <code>top 10</code> 占用了 <code>44.50%</code> 其中 <code>bytes.makeSlice</code> 占了接近 <code>1/10</code>，那么看看都是谁在调用 <code>bytes.makeSlice</code> 吧。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pprof) web bytes.makeSlice</span><br></pre></td></tr></table></figure><p><img src="/assets/image/20190126/1.jpg" alt="image-1"></p><p>从上图可以看出调用 <code>bytes.makeSlice</code> 的最终方法是 <code>ioutil.ReadAll</code>, (受篇幅影响就没有截取 <code>ioutil.ReadAll</code> 上面的方法了)，而 90% 都是 <code>ioutil.ReadAll</code> 读取 <code>http</code> 数据调用，找到地方先别急想优化方案，先看看为啥 <code>ioutil.ReadAll</code> 会导致这么多内存分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readAll</span><span class="params">(r io.Reader, capacity <span class="keyword">int64</span>)</span> <span class="params">(b []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="comment">// If the buffer overflows, we will get bytes.ErrTooLarge.</span></span><br><span class="line"><span class="comment">// Return that as an error. Any other panic remains.</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> panicErr, ok := e.(error); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123;</span><br><span class="line">err = panicErr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(<span class="keyword">int</span>(capacity)) == capacity &#123;</span><br><span class="line">buf.Grow(<span class="keyword">int</span>(capacity))</span><br><span class="line">&#125;</span><br><span class="line">_, err = buf.ReadFrom(r)</span><br><span class="line"><span class="keyword">return</span> buf.Bytes(), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> readAll(r, bytes.MinRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是标准库 <code>ioutil.ReadAll</code> 的代码，每次会创建一个 <code>var buf bytes.Buffer</code> 并且初始化 <code>buf.Grow(int(capacity))</code> 的大小为 <code>bytes.MinRead</code>, 这个值呢就是 <code>512</code>，按这个 <code>buffer</code> 的大小读取一次数据需要分配 2~16 次内存，天啊简直不能忍，我自己创建一个 <code>buffer</code> 好不好。</p><p>看一下火焰图🔥吧，其中红框标记的就是 <code>ioutil.ReadAll</code> 的部分，颜色比较鲜艳。</p><p><img src="/assets/image/20190126/2.jpg" alt="image-2"></p><h2 id="优化读取方法"><a href="#优化读取方法" class="headerlink" title="优化读取方法"></a>优化读取方法</h2><p>自己创建足够大的 <code>buffer</code> 减少因为容量不够导致的多次扩容问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>))</span><br><span class="line">_, err := io.Copy(buffer, request.Body)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩恩这样应该差不多了，为啥是初始化 <code>4096</code> 的大小，这是个均值，即使比 <code>4096</code> 大基本也就多分配一次内存即可，而且大多数数据都是比 <code>4096</code> 小的。</p><p>但是这样真的就算好了吗，当然不能这样，这个 <code>buffer</code> 个每请求都要创建一次，是不是应该考虑一下复用呢，使用 <code>sync.Pool</code> 建立一个缓冲池效果就更好了。</p><p>以下是优化读取请求的简化代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/json-iterator/go"</span></span><br><span class="line"><span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="string">"github.com/thinkeridea/go-extend/exbytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">pool sync.Pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Adapter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Adapter&#123;</span><br><span class="line">pool: sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *Adapter)</span> <span class="title">GetRequest</span><span class="params">(r *http.Request)</span> <span class="params">(*Request, error)</span></span> &#123;</span><br><span class="line">buffer := api.pool.Get().(*bytes.Buffer)</span><br><span class="line">buffer.Reset()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> buffer != <span class="literal">nil</span> &#123;</span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_, err := io.Copy(buffer, r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request := &amp;Request&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err = jsoniter.Unmarshal(buffer.Bytes(), request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"json"</span>: exbytes.ToString(buffer.Bytes()),</span><br><span class="line">&#125;).Errorf(<span class="string">"jsoniter.UnmarshalJSON fail. error:%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> request, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sync.Pool</code> 的方式是不是有点怪，主要是 <code>defer</code> 和 <code>api.pool.Put(buffer)；buffer = nil</code> 这里解释一下，为了提高 <code>buufer</code> 的复用率会在不使用时尽快把 <code>buffer</code> 放回到缓冲池中，<code>defer</code> 之所以会判断 <code>buffer != nil</code> 主要是在业务逻辑出现错误时，但是 <code>buffer</code> 还没有放回缓冲池时把 <code>buffer</code> 放回到缓冲池，因为在每个错误处理之后都写 <code>api.pool.Put(buffer)</code> 不是一个好的方法，而且容易忘记，但是如果在确定不再使用时 <code>api.pool.Put(buffer)；buffer = nil</code> 就可以尽早把 <code>buffer</code> 放回到缓冲池中，提高复用率，减少新建 <code>buffer</code>。</p><p>这样就好了吗，别急，之前说服务里面还会构建请求，看看构建请求如何优化吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/json-iterator/go"</span></span><br><span class="line"><span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="string">"github.com/thinkeridea/go-extend/exbytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">pool sync.Pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Adapter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Adapter&#123;</span><br><span class="line">pool: sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *Adapter)</span> <span class="title">Request</span><span class="params">(r *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">buffer := api.pool.Get().(*bytes.Buffer)</span><br><span class="line">buffer.Reset()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> buffer != <span class="literal">nil</span> &#123;</span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">e := jsoniter.NewEncoder(buffer)</span><br><span class="line">err = e.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"request"</span>: r,</span><br><span class="line">&#125;).Errorf(<span class="string">"jsoniter.Marshal failure: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"jsoniter.Marshal failure: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := buffer.Bytes()</span><br><span class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://xxx.com"</span>, buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"data"</span>: exbytes.ToString(data),</span><br><span class="line">&#125;).Errorf(<span class="string">"http.NewRequest failed: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"http.NewRequest failed: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Set(<span class="string">"User-Agent"</span>, <span class="string">"xxx"</span>)</span><br><span class="line"></span><br><span class="line">httpResponse, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> httpResponse != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">io.Copy(ioutil.Discard, httpResponse.Body)</span><br><span class="line">httpResponse.Body.Close()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"url"</span>: <span class="string">"http://xxx.com"</span>,</span><br><span class="line">&#125;).Errorf(<span class="string">"query service failed %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"query service failed %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> httpResponse.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"url"</span>:         <span class="string">"http://xxx.com"</span>,</span><br><span class="line"><span class="string">"status"</span>:      httpResponse.Status,</span><br><span class="line"><span class="string">"status_code"</span>: httpResponse.StatusCode,</span><br><span class="line">&#125;).Errorf(<span class="string">"invalid http status code"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid http status code"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer.Reset()</span><br><span class="line">_, err = io.Copy(buffer, httpResponse.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"adapter io.copy failure error:%v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">respData := buffer.Bytes()</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"response_json"</span>: exbytes.ToString(respData),</span><br><span class="line">&#125;).Debug(<span class="string">"response json"</span>)</span><br><span class="line"></span><br><span class="line">res := &amp;Response&#123;&#125;</span><br><span class="line">err = jsoniter.Unmarshal(respData, res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">"data"</span>: exbytes.ToString(respData),</span><br><span class="line"><span class="string">"url"</span>:  <span class="string">"http://xxx.com"</span>,</span><br><span class="line">&#125;).Errorf(<span class="string">"adapter jsoniter.Unmarshal failed, error:%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"adapter jsoniter.Unmarshal failed, error:%v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例和之前差不多，只是不仅用来读取 <code>http.Response.Body</code> 还用来创建一个 <code>jsoniter.NewEncoder</code> 用来把请求压缩成 <code>json</code> 字符串，并且作为 <code>http.NewRequest</code> 的 <code>body</code> 参数， 如果直接用 <code>jsoniter.Marshal</code> 同样会创建很多次内存，<code>jsoniter</code> 也使用 <code>buffer</code> 做为缓冲区，并且默认大小为 <code>512</code>, 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg Config)</span> <span class="title">Froze</span><span class="params">()</span> <span class="title">API</span></span> &#123;</span><br><span class="line">api := &amp;frozenConfig&#123;</span><br><span class="line">sortMapKeys:                   cfg.SortMapKeys,</span><br><span class="line">indentionStep:                 cfg.IndentionStep,</span><br><span class="line">objectFieldMustBeSimpleString: cfg.ObjectFieldMustBeSimpleString,</span><br><span class="line">onlyTaggedField:               cfg.OnlyTaggedField,</span><br><span class="line">disallowUnknownFields:         cfg.DisallowUnknownFields,</span><br><span class="line">&#125;</span><br><span class="line">api.streamPool = &amp;sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> NewStream(api, <span class="literal">nil</span>, <span class="number">512</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line"><span class="keyword">return</span> api</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且序列化之后会进行一次数据拷贝：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg *frozenConfig)</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">stream := cfg.BorrowStream(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> cfg.ReturnStream(stream)</span><br><span class="line">stream.WriteVal(v)</span><br><span class="line"><span class="keyword">if</span> stream.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, stream.Error</span><br><span class="line">&#125;</span><br><span class="line">result := stream.Buffer()</span><br><span class="line">copied := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(result))</span><br><span class="line"><span class="built_in">copy</span>(copied, result)</span><br><span class="line"><span class="keyword">return</span> copied, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然要用 <code>buffer</code> 那就一起吧^_^，这样可以减少多次内存分配，下读取 <code>http.Response.Body</code> 之前一定要记得 <code>buffer.Reset()</code>， 这样基本就已经完成了 <code>http.Request.Body</code> 和 <code>http.Response.Body</code> 的数据读取优化了，具体效果等上线跑一段时间稳定之后来查看吧。</p><h2 id="效果分析"><a href="#效果分析" class="headerlink" title="效果分析"></a>效果分析</h2><p>上线跑了一天，来看看效果吧</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof allocs2</span><br><span class="line">File: connect_server</span><br><span class="line">Type: alloc_space</span><br><span class="line">Time: Jan <span class="number">26</span>, <span class="number">2019</span> at <span class="number">10</span>:<span class="number">27</span>am (CST)</span><br><span class="line">Entering interactive mode (type <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">295.40</span>GB, <span class="number">40.62</span>% of <span class="number">727.32</span>GB total</span><br><span class="line">Dropped <span class="number">738</span> nodes (cum &lt;= <span class="number">3.64</span>GB)</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">174</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">   <span class="number">73.52</span>GB <span class="number">10.11</span>% <span class="number">10.11</span>%    <span class="number">73.52</span>GB <span class="number">10.11</span>%  git.tvblack.com/tvblack/connect_server/vendor/github.com/sirupsen/logrus.(*Entry).WithFields</span><br><span class="line">   <span class="number">31.70</span>GB  <span class="number">4.36</span>% <span class="number">14.47</span>%    <span class="number">31.70</span>GB  <span class="number">4.36</span>%  net/url.unescape</span><br><span class="line">   <span class="number">27.49</span>GB  <span class="number">3.78</span>% <span class="number">18.25</span>%    <span class="number">54.87</span>GB  <span class="number">7.54</span>%  git.tvblack.com/tvblack/connect_server/models.LogItemsToBytes</span><br><span class="line">   <span class="number">27.41</span>GB  <span class="number">3.77</span>% <span class="number">22.01</span>%    <span class="number">27.41</span>GB  <span class="number">3.77</span>%  strings.Join</span><br><span class="line">   <span class="number">25.04</span>GB  <span class="number">3.44</span>% <span class="number">25.46</span>%    <span class="number">25.04</span>GB  <span class="number">3.44</span>%  bufio.NewWriterSize</span><br><span class="line">   <span class="number">24.81</span>GB  <span class="number">3.41</span>% <span class="number">28.87</span>%    <span class="number">24.81</span>GB  <span class="number">3.41</span>%  bufio.NewReaderSize</span><br><span class="line">   <span class="number">23.91</span>GB  <span class="number">3.29</span>% <span class="number">32.15</span>%    <span class="number">23.91</span>GB  <span class="number">3.29</span>%  regexp.(*bitState).reset</span><br><span class="line">   <span class="number">23.06</span>GB  <span class="number">3.17</span>% <span class="number">35.32</span>%    <span class="number">23.06</span>GB  <span class="number">3.17</span>%  math/big.nat.make</span><br><span class="line">   <span class="number">19.90</span>GB  <span class="number">2.74</span>% <span class="number">38.06</span>%    <span class="number">20.35</span>GB  <span class="number">2.80</span>%  git.tvblack.com/tvblack/connect_server/vendor/github.com/json-iterator/go.(*Iterator).readStringSlowPath</span><br><span class="line">   <span class="number">18.58</span>GB  <span class="number">2.56</span>% <span class="number">40.62</span>%    <span class="number">19.12</span>GB  <span class="number">2.63</span>%  net/textproto.(*Reader).ReadMIMEHeader</span><br></pre></td></tr></table></figure><p>哇塞 <code>bytes.makeSlice</code> 终于从前十中消失了，真的太棒了，还是看看 <code>bytes.makeSlice</code> 的其它调用情况吧。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pprof) web bytes.makeSlice</span><br></pre></td></tr></table></figure><p><img src="/assets/image/20190126/3.jpg" alt="image-3"></p><p>从图中可以发现 <code>bytes.makeSlice</code> 的分配已经很小了， 且大多数是 <code>http.Request.ParseForm</code> 读取 <code>http.Request.Body</code> 使用 <code>ioutil.ReadAll</code> 原因，这次优化的效果非常的好。</p><p>看一下更直观的火焰图🔥吧，和优化前对比一下很明显 <code>ioutil.ReadAll</code> 看不到了</p><p><img src="/assets/image/20190126/4.jpg" alt="image-4"></p><h2 id="优化期间遇到的问题"><a href="#优化期间遇到的问题" class="headerlink" title="优化期间遇到的问题"></a>优化期间遇到的问题</h2><p>比较惭愧在优化的过程出现了一个过失，导致生产环境2分钟故障，通过自动部署立即回滚才得以快速恢复，之后分析代码解决之后上线才完美优化，下面总结一下出现的问题吧。</p><p>在构建 <code>http</code> 请求时我分了两个部分优化，序列化 <code>json</code> 和读取 <code>http.Response.Body</code> 数据，保持一个观点就是尽早把 <code>buffer</code> 放回到缓冲池，因为 <code>http.DefaultClient.Do(req)</code> 是网络请求会相对耗时，在这个之前我把 <code>buffer</code> 放回到缓冲池中，之后读取 <code>http.Response.Body</code> 时在重新获取一个 <code>buffer</code>，大概代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/json-iterator/go"</span></span><br><span class="line"><span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="string">"github.com/thinkeridea/go-extend/exbytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">pool sync.Pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Adapter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Adapter&#123;</span><br><span class="line">pool: sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *Adapter)</span> <span class="title">Request</span><span class="params">(r *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">buffer := api.pool.Get().(*bytes.Buffer)</span><br><span class="line">buffer.Reset()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> buffer != <span class="literal">nil</span> &#123;</span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">e := jsoniter.NewEncoder(buffer)</span><br><span class="line">err = e.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"jsoniter.Marshal failure: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := buffer.Bytes()</span><br><span class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://xxx.com"</span>, buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"http.NewRequest failed: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Set(<span class="string">"User-Agent"</span>, <span class="string">"xxx"</span>)</span><br><span class="line"></span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">httpResponse, err := http.DefaultClient.Do(req)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">buffer = api.pool.Get().(*bytes.Buffer)</span><br><span class="line">buffer.Reset()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> buffer != <span class="literal">nil</span> &#123;</span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">_, err = io.Copy(buffer, httpResponse.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"adapter io.copy failure error:%v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">api.pool.Put(buffer)</span><br><span class="line">buffer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上线之后马上发生了错误 <code>http: ContentLength=2090 with Body length 0</code> 发送请求的时候从 <code>buffer</code> 读取数据发现数据不见了或者数据不够了，我去这是什么鬼，马上回滚恢复业务，然后分析 <code>http.DefaultClient.Do(req)</code> 和 <code>http.NewRequest</code>，在调用 <code>http.NewRequest</code> 是并没有从 <code>buffer</code> 读取数据，而只是创建了一个 <code>req.GetBody</code> 之后在 <code>http.DefaultClient.Do</code> 是才读取数据，因为在 <code>http.DefaultClient.Do</code> 之前把 <code>buffer</code> 放回到缓冲池中，其它 <code>goroutine</code> 获取到 <code>buffer</code> 并进行 <code>Reset</code> 就发生了数据争用，当然会导致数据读取不完整了，真实汗颜，对 <code>http.Client</code> 了解太少，争取有空撸一遍源码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用合适大小的 <code>buffer</code> 来减少内存分配，<code>sync.Pool</code> 可以帮助复用 <code>buffer</code>， 一定要自己写这些逻辑，避免使用三方包，三方包即使使用同样的技巧为了避免数据争用，在返回数据时候必然会拷贝一个新的数据返回，就像 <code>jsoniter</code> 虽然使用了 <code>sync.Pool</code> 和 <code>buffer</code> 但是返回数据时还需要拷贝，另外这种通用包并不能给一个非常贴合业务的初始 <code>buffer</code> 大小，过小会导致数据发生拷贝，过大会太过浪费内存。</p><p>程序中善用 <code>buffer</code> 和 <code>sync.Pool</code> 可以大大的改善程序的性能，并且这两个组合在一起使用非常的简单，并不会使代码变的复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 &lt;code&gt;http.Request.Body&lt;/code&gt; 或 &lt;code&gt;http.Response.Body&lt;/code&gt; 中读取数据方法或许很多，标准库中大多数使用 &lt;code&gt;ioutil.ReadAll&lt;/code&gt; 方法一次读取所有数据，如果是 &lt;code&gt;json&lt;/code&gt; 格式的数据还可以使用 &lt;code&gt;json.NewDecoder&lt;/code&gt; 从 &lt;code&gt;io.Reader&lt;/code&gt; 创建一个解析器，假使使用 &lt;code&gt;pprof&lt;/code&gt; 来分析程序总是会发现 &lt;code&gt;bytes.makeSlice&lt;/code&gt; 分配了大量内存，且总是排行第一，今天就这个问题来说一下如何高效优雅的读取 &lt;code&gt;http&lt;/code&gt; 中的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="https://blog.thinkeridea.com/categories/go/"/>
    
    
      <category term="net.http" scheme="https://blog.thinkeridea.com/tags/net-http/"/>
    
      <category term="http" scheme="https://blog.thinkeridea.com/tags/http/"/>
    
      <category term="pool" scheme="https://blog.thinkeridea.com/tags/pool/"/>
    
      <category term="bytes" scheme="https://blog.thinkeridea.com/tags/bytes/"/>
    
      <category term="buffer" scheme="https://blog.thinkeridea.com/tags/buffer/"/>
    
      <category term="makeSlice" scheme="https://blog.thinkeridea.com/tags/makeslice/"/>
    
      <category term="ioutil" scheme="https://blog.thinkeridea.com/tags/ioutil/"/>
    
  </entry>
  
  <entry>
    <title>【Go】slice的一些使用技巧</title>
    <link href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html"/>
    <id>https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</id>
    <published>2019-01-22T22:34:57.000Z</published>
    <updated>2019-01-26T12:01:42.402Z</updated>
    
    <content type="html"><![CDATA[<p><code>slice</code> 是 <code>Go</code> 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 <code>Go</code> 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 <code>Go</code> 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 <code>slice</code> 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。</p><p>在 <code>Go</code> 语言项目中大量的使用 <code>slice</code>, 我总结三年来对 <code>slice</code> 的一些操作技巧，以方便可以高效的使用 <code>slice</code>， 并使用 <code>slice</code> 解决一些棘手的问题。</p><h2 id="slice-的基本操作"><a href="#slice-的基本操作" class="headerlink" title="slice 的基本操作"></a>slice 的基本操作</h2><p>先熟悉一些 <code>slice</code> 的基本的操作, 对最常规的 <code>:</code> 操作就可玩出很多花样。</p><ul><li><code>s=ss[:]</code> 引用一个切片或数组</li><li><code>s=s[:0]</code> 清空切片</li><li><code>s=s[:10]</code> <code>s=s[10:]</code> <code>s=s[10:20]</code> 截取接片</li><li><code>s=ss[0:10:20]</code> 从切片或数组引用指定长度和容量的切片</li></ul><p>下标索引操作的一些误区 <code>s[i:l:c]</code> <code>i</code> 是起始偏移的起始位置，<code>l</code> 是起始偏移的长度结束位置， <code>l-i</code> 就是新 <code>slice</code> 的长度， <code>c</code> 是起始偏移的容量结束位置，<code>c-i</code> 就是新 <code>slice</code> 的容量。其中 <code>i</code> 、<code>l</code> 、<code>c</code> 并不是当前 <code>slice</code> 的索引，而是引用底层数组相对当前 <code>slice</code> 起始位置的偏移量，所以是可超出当前 <code>slice</code> 的长度的， 但不能超出当前 <code>slice</code> 的容量，如下操作是合法的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">s[<span class="number">20</span>] = <span class="number">100</span></span><br><span class="line">s1 := s[<span class="number">10</span>:<span class="number">10</span>]</span><br><span class="line">s2 := s1[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>s1</code> 是 <code>[]</code>；<code>s2</code> 是 <code>[100 0 0 0 0 0 0 0 0 0]</code>, 这里并不会发生下标越界的情况，一个更好的例子在 <a href="#csv-reader-中的一个例子">csv reader 中的一个例子</a></p><a id="more"></a><p><strong>创建 slice</strong></p><p>创建切片的方法有很多，下面罗列一些常规的：</p><ul><li><code>var s []int</code> 创建 nil切片</li><li><code>s := make([]int, 0, 0)</code> 、 <code>s=[]int{}</code> 创建无容量空切片</li><li><code>s:= make([]int, 0, 100)</code> 创建有容量空切片</li><li><code>s:=make([]int, 100)</code> 创建零值切片</li><li><code>s:=array[:]</code> 引用数组创建切片</li></ul><p><strong>内置函数</strong></p><ul><li><code>len(s)</code> 获取切片的长度</li><li><code>cap(s)</code> 获取切片的容量</li><li><code>append(s, ...)</code> 向切片追加内容</li><li><code>copy(s, s1)</code> 向切片拷贝内容</li></ul><h2 id="一个缓冲的简单示例"><a href="#一个缓冲的简单示例" class="headerlink" title="一个缓冲的简单示例"></a>一个缓冲的简单示例</h2><p>遇到过很多拼接字符串的方法，各种各样的都有 <code>fmt</code> <code>builder</code> <code>buffer</code> <code>+</code> 等等，实际上 <code>builder</code> 和 <code>buffer</code> 都是使用 <code>[]byte</code> 的切片作为缓冲来实现的，<code>fmt</code> 往往性能最差，原因是它主要功能不是连接字符串而是格式化数据会用到反射等等操作。<code>+</code> 操作在大量拼接时性能也是很差， 不过小字符串少量拼接效果很理想，<code>builder</code> 往往性能不如 <code>buffer</code> 特别是在较短字符串拼接上，实际 <code>builder</code> 和 <code>buffer</code> 实现原理非常类似，<code>builder</code> 在转成字符串时使用了 <code>unsafe</code> 减少了一次内存分配，因为小字符串因为扩容机制不如 <code>buffer</code> 灵活，所以性能有所不如，大字符串降低一次大的内存分配就显得很明显了。</p><p>经常遇到一个需求就是拼接 <code>[]int</code> 中个各个元素，很多种实现都有人用，都是需要遍历转换 <code>int</code> 到 <code>string</code>，但是拼接方法千奇百怪，以下提供两种方法对比（<a href="https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string.go" target="_blank" rel="noopener">源码在GitHub</a>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> slice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceInt2String1</span><span class="params">(s []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ss := strconv.Itoa(s[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">ss += <span class="string">","</span> + strconv.Itoa(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ss</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceInt2String2</span><span class="params">(s []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, strconv.Itoa(s[<span class="number">0</span>])...)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">','</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, strconv.Itoa(s[i])...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceInt2String3</span><span class="params">(s []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, strconv.Itoa(s[<span class="number">0</span>])...)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">','</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, strconv.Itoa(s[i])...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SliceInt2String1</code> 使用原始的 <code>+</code> 操作，因为是较小的字符串拼接，使用 <code>+</code> 主要是因为在小字符串拼接性能优于其它几种方法，<code>SliceInt2String2</code> 与 <code>SliceInt2String3</code> 都使用了一个 <code>256</code> 容量的 <code>[]byte</code> 作为缓冲， 唯一的区别是在返回时一个使用 <code>string</code> 转换类型，一个使用 <code>unsafe</code> 转换类型。</p><p>写了一个性能测试（<a href="https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string_test.go" target="_blank" rel="noopener">源码在GitHub</a>），看一下效果吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/thinkeridea/example/slice</span><br><span class="line">BenchmarkSliceInt2String1-8    3000000       461 ns/op     144 B/op       9 allocs/op</span><br><span class="line">BenchmarkSliceInt2String2-8   20000000       117 ns/op      32 B/op       1 allocs/op</span><br><span class="line">BenchmarkSliceInt2String3-8   10000000       144 ns/op     256 B/op       1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  github.com/thinkeridea/example/slice5.928s</span><br></pre></td></tr></table></figure><p>明显可以看得出 <code>SliceInt2String2</code> 的性能是 <code>SliceInt2String1</code> 7倍左右，提升很明显，<code>SliceInt2String2</code> 与 <code>SliceInt2String3</code> 差异很小，主要是因为使用 <code>unsafe</code>  转换类型导致大内存无法释放，实际这个测试中连接字符串只需要 <code>32</code> 个字节，使用 <code>unsafe</code> 却导致 <code>256</code> 个字节无法被释放，这也正是 <code>builder</code> 和 <code>buffer</code> 的差别，所以小字符串拼接 <code>buffer</code> 性能往往更好。在这里简单的通过 <code>[]byte</code> 减少内存分配次数来实现缓冲。</p><p>如果连续拼接一组这样的操作，比如输入 <code>[][]int</code>,  输出 <code>[]string</code> （<a href="https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string.go#L52" target="_blank" rel="noopener">源码在GitHub</a>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> slice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceInt2String4</span><span class="params">(s [][]<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(v) &lt; <span class="number">1</span> &#123;</span><br><span class="line">res[i] = <span class="string">""</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res[i] += strconv.Itoa(v[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(v); j++ &#123;</span><br><span class="line">res[i] += <span class="string">","</span> + strconv.Itoa(v[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceInt2String5</span><span class="params">(s [][]<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(v) &lt; <span class="number">1</span> &#123;</span><br><span class="line">res[i] = <span class="string">""</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = b[:<span class="number">0</span>]</span><br><span class="line">b = <span class="built_in">append</span>(b, strconv.Itoa(v[<span class="number">0</span>])...)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(v); j++ &#123;</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">','</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, strconv.Itoa(v[j])...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res[i] = <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SliceInt2String5</code> 中使用 <code>b = b[:0]</code>  来促使达到反复使用一块缓冲区，写了一个性能测试（<a href="https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string_test.go#L85" target="_blank" rel="noopener">源码在GitHub</a>），看一下效果吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/thinkeridea/example/slice</span><br><span class="line">BenchmarkSliceInt2String4-8     300000      4420 ns/op    1440 B/op      82 allocs/op</span><br><span class="line">BenchmarkSliceInt2String5-8    1000000      1102 ns/op     432 B/op      10 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  github.com/thinkeridea/example/slice8.364s</span><br></pre></td></tr></table></figure><p>较 <code>+</code> 版本提升接近4倍的性能，这是使用 <code>slice</code> 作为缓冲区极好的技巧，使用非常方便，并不用使用 <code>builder</code> 和 <code>buffer</code>， <code>slice</code> 操作非常的简单实用。</p><h2 id="append-与-copy"><a href="#append-与-copy" class="headerlink" title="append 与 copy"></a>append 与 copy</h2><p>如果合并多个 <code>slice</code> 为一个，有三种方式来合并，主要合并差异来源于创建新 <code>slice</code> 的方法，使用 <code>var news []int</code> 或者 <code>news:=make([]int, 0, len(s1)+len(s2)....)</code> 的方式创建的新变量就需要使用 <code>append</code> 来合并，如果使用 <code>news:=make([]int, len(s1)+len(s2)....)</code> 就需要使用 <code>copy</code> 来合并。不同的方法也有差异，<code>append</code> 和 <code>copy</code> 在这个例子中主要差异在于 <code>append</code> 适用于零长度的初始化 <code>slice</code>， <code>copy</code> 适用于确定长度的 <code>slice</code>。</p><p>写了一个测试来看看两者的差异吧（<a href="https://github.com/thinkeridea/example/blob/master/slice/append_and_copy_test.go" target="_blank" rel="noopener">源码在GitHub</a>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkExperiment3Append1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">20</span>; j++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="keyword">int</span>&#123;j, j + <span class="number">1</span>, j + <span class="number">2</span>, j + <span class="number">3</span>, j + <span class="number">4</span>&#125;...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkExperiment3Append2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">20</span>; j++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="keyword">int</span>&#123;j, j + <span class="number">1</span>, j + <span class="number">2</span>, j + <span class="number">3</span>, j + <span class="number">4</span>&#125;...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkExperiment3Copy</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">20</span>; j++ &#123;</span><br><span class="line">n += <span class="built_in">copy</span>(s[n:], []<span class="keyword">int</span>&#123;j, j + <span class="number">1</span>, j + <span class="number">2</span>, j + <span class="number">3</span>, j + <span class="number">4</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/thinkeridea/example/slice</span><br><span class="line">BenchmarkExperiment3Append1-8    2000000       782 ns/op    3024 B/op       6 allocs/op</span><br><span class="line">BenchmarkExperiment3Append2-8   10000000       192 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkExperiment3Copy-8      10000000       217 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  github.com/thinkeridea/example/slice6.926s</span><br></pre></td></tr></table></figure><p>从结果上来看使用没有容量的 <code>append</code> 性能真的很糟糕，实际上不要对没有任何容量的 <code>slice</code> 进行 <code>append</code> 操作是最好的实践，在准备用 <code>append</code> 的时候应该预先给定一个容量，哪怕这个容量并不是确定的，像前面缓存连接字符串时一样，并不能明确使用的空间，先分配256个字节，这样的好处是可以减少系统调用分配内存的次数，即使空间不能用完，也不用太过担心浪费，<code>append</code> 本身扩容机制也会导致空间不是刚刚好用完的，而初始化的容量往往结合业务场景给的一个均值，这是很好的。</p><p><code>append</code> 和 <code>copy</code> 在预先确定长度和容量时 <code>append</code> 效果更好一些，主要原因是 <code>copy</code> 需要一个变量来记录位置。 如果使用场景中没有强制限定长度，建议使用 <code>append</code> 因为 <code>append</code> 会根据实际情况再做内存分配，较 <code>copy</code> 也更加灵活一些， 而 <code>copy</code> 往往用在长度固定的地方，可以防止数据长度溢出的问题，例如标准库中 <code>strings.Repeat</code> 函数，它采用指数增长的方式快速填充指定数量的字符，但是如果使用 <code>append</code> 就会发生多余的内存分配，导致长度溢出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s)*count)</span><br><span class="line">bp := <span class="built_in">copy</span>(b, s)</span><br><span class="line"><span class="keyword">for</span> bp &lt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line"><span class="built_in">copy</span>(b[bp:], b[:bp])</span><br><span class="line">bp *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="csv-reader-中的一个例子"><a href="#csv-reader-中的一个例子" class="headerlink" title="csv reader 中的一个例子"></a>csv reader 中的一个例子</h2><p>官方标准库 <code>csv</code> 的读取性能极高，其中 <code>reader</code> 里面有使用 <code>slice</code> 极好的例子，以下是简略的代码，如果想要全面了解程序需要去看标准库的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">readRecord</span><span class="params">(dst []<span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">line, errRead = r.readLine()</span><br><span class="line"><span class="keyword">if</span> errRead == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errRead</span><br><span class="line">&#125;</span><br><span class="line">r.recordBuffer = r.recordBuffer[:<span class="number">0</span>]</span><br><span class="line">r.fieldIndexes = r.fieldIndexes[:<span class="number">0</span>]</span><br><span class="line">parseField:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.TrimLeadingSpace &#123;</span><br><span class="line">line = bytes.TrimLeftFunc(line, unicode.IsSpace)</span><br><span class="line">&#125;</span><br><span class="line">i := bytes.IndexRune(line, r.Comma)</span><br><span class="line">field := line</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">field = field[:i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">field = field[:<span class="built_in">len</span>(field)-lengthNL(field)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.recordBuffer = <span class="built_in">append</span>(r.recordBuffer, field...)</span><br><span class="line">r.fieldIndexes = <span class="built_in">append</span>(r.fieldIndexes, <span class="built_in">len</span>(r.recordBuffer))</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">line = line[i+commaLen:]</span><br><span class="line"><span class="keyword">continue</span> parseField</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span> parseField</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = errRead</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a single string and create slices out of it.</span></span><br><span class="line"><span class="comment">// This pins the memory of the fields together, but allocates once.</span></span><br><span class="line">str := <span class="keyword">string</span>(r.recordBuffer) <span class="comment">// Convert to string once to batch allocations</span></span><br><span class="line">dst = dst[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(dst) &lt; <span class="built_in">len</span>(r.fieldIndexes) &#123;</span><br><span class="line">dst = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(r.fieldIndexes))</span><br><span class="line">&#125;</span><br><span class="line">dst = dst[:<span class="built_in">len</span>(r.fieldIndexes)]</span><br><span class="line"><span class="keyword">var</span> preIdx <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i, idx := <span class="keyword">range</span> r.fieldIndexes &#123;</span><br><span class="line">dst[i] = str[preIdx:idx]</span><br><span class="line">preIdx = idx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里删除了极多的代码，但是能看懂大意，其中 <code>line</code> 是一段 <code>bufio</code> 中的一段引用，所以这块数据不能返回给用户，也不能进行并发读取操作。</p><p><code>r.recordBuffer</code> 和 <code>r.fieldIndexes</code> 是 <code>csv</code> 的缓存，他们初始的时候容量是0，是不是会有些奇怪，之前还建议 <code>slice</code> 初始一个长度，来减少内存分配，<code>csv</code> 这个库的设计非常的巧妙，假设 <code>csv</code> 每行字段的个数一样，数据长度也相近，现实业务确实如此，所以只有读取第一行数据的时候才会发生大量的 <code>slice</code> 扩容， 之后其它行扩容的可能性非常的小，整个文件读取完也不会发生太多次，不得不说设计的太妙了。</p><p><code>r.recordBuffer</code> 用来存储行中除了分隔符的所有数据，<code>r.fieldIndexes</code> 用来存储每个字段数据在 <code>r.recordBuffer</code> 中的索引。每次都通过 <code>r.recordBuffer[:0]</code> 这个的数据获取，读取每行数据都反复使用这块内存，极大的减少内存开销。</p><p>更巧妙的设计是 <code>str := string(r.recordBuffer)</code> 源代码中也有详细的说明，一次性分配足够的内存， 要知道类型转换是会发生内存拷贝的，分配新的内存， 如果每个字段转换一次，会发生很多的内存拷贝和分配，之后通过 <code>dst[i] = str[preIdx:idx]</code> 引用 <code>str</code> 中的数据达到切分字段的效果，因为引用字符串并不会拷贝字符串（字符串不可变，引用字符串的子串是安全的）所以其代价非常的小。</p><p>这段源码中还有一个很多人都不知道的 <code>slice</code> 特性的例子，<code>dst = dst[:0]; dst = dst[:len(r.fieldIndexes)]</code> 这两句话放到一起是不是感觉很不可思议，明明 <code>dst</code> 的长度被清空了，<code>dst[:len(r.fieldIndexes)]</code> 不是会发生索引越界吗，很多人认为 <code>s[i:l]</code> 这种写法是当前 <code>slice</code> 的索引，实际并非如此，这里面的 <code>i</code> 和 <code>j</code> 是底层引用数组相对当前 <code>slice</code> 引用位置的索引，并不受当前 <code>slice</code> 的长度的影响。</p><p>这里只是简单引用 <code>csv</code> 源码中的一段分析其 <code>slice</code> 的巧妙用法，即把 <code>slice</code> 当做数据缓存，也作为分配内存的一种极佳的方法，这个示例中的关于 <code>slice</code> 的使用值得反复推敲。</p><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>早些时间阅读 GitHub 上的一些源码，发现一个实现内存次的例子，里面对 <code>slice</code> 的应用非常有特点，在这里拿来分析一下（<a href="https://github.com/funny/slab/blob/master/chan_pool.go" target="_blank" rel="noopener">GitHub源码</a>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChanPool</span><span class="params">(minSize, maxSize, factor, pageSize <span class="keyword">int</span>)</span> *<span class="title">ChanPool</span></span> &#123;</span><br><span class="line">pool := &amp;ChanPool&#123;<span class="built_in">make</span>([]chanClass, <span class="number">0</span>, <span class="number">10</span>), minSize, maxSize&#125;</span><br><span class="line"><span class="keyword">for</span> chunkSize := minSize; chunkSize &lt;= maxSize &amp;&amp; chunkSize &lt;= pageSize; chunkSize *= factor &#123;</span><br><span class="line">c := chanClass&#123;</span><br><span class="line">size:   chunkSize,</span><br><span class="line">page:   <span class="built_in">make</span>([]<span class="keyword">byte</span>, pageSize),</span><br><span class="line">chunks: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, pageSize/chunkSize),</span><br><span class="line">&#125;</span><br><span class="line">c.pageBegin = <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;c.page[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pageSize/chunkSize; i++ &#123;</span><br><span class="line"><span class="comment">// lock down the capacity to protect append operation</span></span><br><span class="line">mem := c.page[i*chunkSize : (i+<span class="number">1</span>)*chunkSize : (i+<span class="number">1</span>)*chunkSize]</span><br><span class="line">c.chunks &lt;- mem</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(c.chunks)<span class="number">-1</span> &#123;</span><br><span class="line">c.pageEnd = <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;mem[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pool.classes = <span class="built_in">append</span>(pool.classes, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用步进式分页，保证每页上的数据块大小相同，一次性创建整个页 <code>make([]byte, pageSize)</code> ，之后从页切分数据块 <code>mem := c.page[i*chunkSize : (i+1)*chunkSize : (i+1)*chunkSize]</code>， 容量和数据块长度一致，创建一块较大的内存，减少系统调用，当然这个例子中还可以创建更大的内存，就是每页容量的总大小，避免创建更多页，所有的块数据都引用一块内存。</p><p>这里限制了每个块的容量，默认引用 <code>slice</code> 的容量是引用起始位置到底层数组的结尾，但是可以指定容量，这就保证了获取的数据块不会因为用户不遵守约定超出其大小导致数据写入到其它块中的问题，设定了容量用户使用超出容量后就会拷贝出去并创建新的 <code>slice</code> 实在的很妙的用法。</p><p>一次分配更大的内存可以减少内存碎片，更好的复用内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ChanPool)</span> <span class="title">Alloc</span><span class="params">(size <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt;= pool.maxSize &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pool.classes); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> pool.classes[i].size &gt;= size &#123;</span><br><span class="line">mem := pool.classes[i].Pop()</span><br><span class="line"><span class="keyword">if</span> mem != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mem[:size]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取内存池中的内存就非常简单，查找比需要大小更大的块并返回即可，这不失为一个较好的内存复用算法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ChanPool)</span> <span class="title">Free</span><span class="params">(mem []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">size := <span class="built_in">cap</span>(mem)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pool.classes); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> pool.classes[i].size == size &#123;</span><br><span class="line">pool.classes[i].Push(mem)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用完释放内存时实现的并不是很好，应该判断释放的数据是否是当前内存的一部分，如果不是的就不能放回到内存池中，因为用户未按约定大小使用，导致大量扩容而使得内存池中的数据碎片化，当然用户一旦发生扩容就会导致内存池中的缓存块丢失，导致存在大块内存无法释放，却也没法使用的情况。</p><p>之所以分析这个例子主要是分析其使用 <code>slice</code> 的方法和技巧，并不推荐使用该方法管理内存。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>更多关于 <code>slice</code> 应用的例子可以参考标准库 <code>bytes</code> 与 <code>bufio</code>， <code>buffer</code> 与 <code>bufio</code> 的使用极其相似，两个包都是使用 <code>slice</code> 来减少内存分配及系统调用来达到实现缓冲和缓存的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是 &lt;code&gt;Go&lt;/code&gt; 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 &lt;code&gt;Go&lt;/code&gt; 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 &lt;code&gt;Go&lt;/code&gt; 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 &lt;code&gt;slice&lt;/code&gt; 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Go&lt;/code&gt; 语言项目中大量的使用 &lt;code&gt;slice&lt;/code&gt;, 我总结三年来对 &lt;code&gt;slice&lt;/code&gt; 的一些操作技巧，以方便可以高效的使用 &lt;code&gt;slice&lt;/code&gt;， 并使用 &lt;code&gt;slice&lt;/code&gt; 解决一些棘手的问题。&lt;/p&gt;
&lt;h2 id=&quot;slice-的基本操作&quot;&gt;&lt;a href=&quot;#slice-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;slice 的基本操作&quot;&gt;&lt;/a&gt;slice 的基本操作&lt;/h2&gt;&lt;p&gt;先熟悉一些 &lt;code&gt;slice&lt;/code&gt; 的基本的操作, 对最常规的 &lt;code&gt;:&lt;/code&gt; 操作就可玩出很多花样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s=ss[:]&lt;/code&gt; 引用一个切片或数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=s[:0]&lt;/code&gt; 清空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=s[:10]&lt;/code&gt; &lt;code&gt;s=s[10:]&lt;/code&gt; &lt;code&gt;s=s[10:20]&lt;/code&gt; 截取接片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=ss[0:10:20]&lt;/code&gt; 从切片或数组引用指定长度和容量的切片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下标索引操作的一些误区 &lt;code&gt;s[i:l:c]&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; 是起始偏移的起始位置，&lt;code&gt;l&lt;/code&gt; 是起始偏移的长度结束位置， &lt;code&gt;l-i&lt;/code&gt; 就是新 &lt;code&gt;slice&lt;/code&gt; 的长度， &lt;code&gt;c&lt;/code&gt; 是起始偏移的容量结束位置，&lt;code&gt;c-i&lt;/code&gt; 就是新 &lt;code&gt;slice&lt;/code&gt; 的容量。其中 &lt;code&gt;i&lt;/code&gt; 、&lt;code&gt;l&lt;/code&gt; 、&lt;code&gt;c&lt;/code&gt; 并不是当前 &lt;code&gt;slice&lt;/code&gt; 的索引，而是引用底层数组相对当前 &lt;code&gt;slice&lt;/code&gt; 起始位置的偏移量，所以是可超出当前 &lt;code&gt;slice&lt;/code&gt; 的长度的， 但不能超出当前 &lt;code&gt;slice&lt;/code&gt; 的容量，如下操作是合法的：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	s := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	s[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	s1 := s[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	s2 := s1[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(s1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(s2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中 &lt;code&gt;s1&lt;/code&gt; 是 &lt;code&gt;[]&lt;/code&gt;；&lt;code&gt;s2&lt;/code&gt; 是 &lt;code&gt;[100 0 0 0 0 0 0 0 0 0]&lt;/code&gt;, 这里并不会发生下标越界的情况，一个更好的例子在 &lt;a href=&quot;#csv-reader-中的一个例子&quot;&gt;csv reader 中的一个例子&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="https://blog.thinkeridea.com/categories/go/"/>
    
    
      <category term="go" scheme="https://blog.thinkeridea.com/tags/go/"/>
    
      <category term="slice" scheme="https://blog.thinkeridea.com/tags/slice/"/>
    
      <category term="缓存" scheme="https://blog.thinkeridea.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="内存池" scheme="https://blog.thinkeridea.com/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【Go】深入剖析slice和array</title>
    <link href="https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html"/>
    <id>https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html</id>
    <published>2019-01-11T22:36:26.000Z</published>
    <updated>2019-01-13T14:40:05.579Z</updated>
    
    <content type="html"><![CDATA[<p><code>array</code> 和 <code>slice</code> 看似相似，却有着极大的不同，但他们之间还有着千次万缕的联系 <code>slice</code> 是引用类型、是 <code>array</code> 的引用，相当于动态数组，<br>这些都是 <code>slice</code> 的特性，但是 <code>slice</code> 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 <code>slice</code> 的情况下，怎样可以高效使用 <code>slice</code>？<br>今天借助 <code>Go</code> 的 <code>unsafe</code> 包来探索 <code>array</code> 和 <code>slice</code> 的各种奥妙。</p><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>slice</code> 是在 <code>array</code> 的基础上实现的，需要先详细了解一下数组。</p><p><strong> 维基上如此介绍数组：</strong></p><blockquote><p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储，利用元素的索引（index）可以计算出该元素对应的存储地址。<br><strong> 数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性：</strong></p><ol><li>请求空间以后大小固定，不能再改变（数据溢出问题）；</li><li>在内存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间；</li><li>在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。</li></ol></blockquote><p>根据维基的介绍，了解到数组是存储在一段连续的内存中，每个元素的类型相同，即是每个元素的宽度相同，可以根据元素的宽度计算元素存储的位置。<br>通过这段介绍总结一下数组有一下特性：</p><ul><li>分配在连续的内存地址上</li><li>元素类型一致，元素存储宽度一致</li><li>空间大小固定，不能修改</li><li>可以通过索引计算出元素对应存储的位置（只需要知道数组内存的起始位置和数据元素宽度即可）</li><li>会出现数据溢出的问题（下标越界）</li></ul><p><code>Go</code> 中的数组如何实现的呢，恰恰就是这么实现的，实际上几乎所有计算机语言，数组的实现都是相似的，也拥有上面总结的特性。<br><code>Go</code> 语言的数组不同于 <code>C</code> 语言或者其他语言的数组，<code>C</code> 语言的数组变量是指向数组第一个元素的指针；<br>而 <code>Go</code> 语言的数组是一个值，<code>Go</code> 语言中的数组是值类型，一个数组变量就表示着整个数组，意味着 <code>Go</code> 语言的数组在传递的时候，传递的是原数组的拷贝。</p><p>在程序中数组的初始化有两种方法 <code>arr := [10]int{}</code> 或 <code>var arr  [10]int</code>，但是不能使用 <code>make</code> 来创建，数组这节结束时再探讨一下这个问题。<br>使用 <code>unsafe</code>来看一下在内存中都是如何存储的吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(unsafe.Sizeof(arr))</span><br><span class="line">size := unsafe.Sizeof(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组指定索引元素的值</span></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>])) + <span class="number">1</span>*size)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数组指定索引元素的值</span></span><br><span class="line">*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>])) + <span class="number">1</span>*size)) = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Println(arr[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出如下 (<a href="https://play.golang.org/p/3v-rAQZG-E6" target="_blank" rel="noopener">Go Playground</a>)：</p><blockquote><p>12<br>2<br>10</p></blockquote><p>首先说 <code>12</code> 是 <code>fmt.Println(unsafe.Sizeof(arr))</code> 输出的，<code>unsafe.Sizeof</code> 用来计算当前变量的值在内存中的大小，<code>12</code> 这个代表一个 <code>int</code> 有4个字节，<code>3 * 4</code> 就是 <code>12</code>。<br>这是在32位平台上运行得出的结果， 如果在64位平台上运行数组的大小是 <code>24</code>。从这里可以看出 <code>[3]int</code> 在内存中由3个连续的 <code>int</code> 类型组成，且有 <code>12</code> 个字节那么长，这就说明了数组在内存中没有存储多余的数据，只存储元素本身。</p><p><code>size := unsafe.Sizeof(arr[0])</code> 用来计算单个元素的宽度，<code>int</code>在32位平台上就是4个字节，<code>uintptr(unsafe.Pointer(&amp;arr[0]))</code> 用来计算数组起始位置的指针，<code>1*size</code> 用来获取索引为1的元素相对数组起始位置的偏移，<code>unsafe.Pointer(uintptr(unsafe.Pointer(&amp;arr[0])) + 1*size))</code> 获取索引为1的元素指针，<code>*(*int)</code> 用来转换指针位置的数据类型， 因为 <code>int</code> 是4个字节，所以只会读取4个字节的数据，由元素类型限制数据宽度，来确定元素的结束位置，因此得到的结果是 <code>2</code>。</p><p>上一个步骤获取元素的值，其中先获取了元素的指针，赋值的时候只需要对这个指针位置设置值就可以了， <code>*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;arr[0])) + 1*size)) = 10</code> 就是用来给指定下标元素赋值。</p><p><img src="/assets/image/20190111/array.jpg" alt="数组在内存中的结构"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n:= <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> arr = [n]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，动态的给数组设定长度，会导致编译错误 <code>non-constant array bound n</code>， 由此推导数组的所有操作都是编译时完成的，会转成对应的指令，通过这个特性知道数组的长度是数组类型不可或缺的一部分，并且必须在编写程序时确定。<br>可以通过 <code>GOOS=linux GOARCH=amd64 go tool compile -S array.go</code> 来获取对应的汇编代码，在 <code>array.go</code> 中做一些数组相关的操作，查看转换对应的指令。</p><p>之前的疑问，为什么数组不能用 <code>make</code> 创建？ 上面分析了解到数组操作是在编译时转换成对应指令的，而 <code>make</code> 是在运行时处理（特殊状态下会做编译器优化，make可以被优化，下面 <code>slice</code> 分析时来讲）。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>因为数组是固定长度且是值传递，很不灵活，所以在 <code>Go</code> 程序中很少看到数组的影子。然而 <code>slice</code> 无处不在，<code>slice</code> 以数组为基础，提供强大的功能和遍历性。<br><code>slice</code> 的类型规范是[]T，<code>slice</code> T元素的类型。与数组类型不同，<code>slice</code> 类型没有指定的长度。</p><p><strong> <code>slice</code> 申明的几种方法：</strong> </p><blockquote><p><code>s := []int{1, 2, 3}</code> 简短的赋值语句<br><code>var s []int</code> <code>var</code> 申明<br><code>make([]int, 3, 8)</code> 或 <code>make([]int, 3)</code> <code>make</code> 内置方法创建<br><code>s := ss[:5]</code> 从切片或者数组创建</p></blockquote><p><strong> <code>slice</code> 有两个内置函数来获取其属性：</strong></p><blockquote><p><code>len</code> 获取 <code>slice</code> 的长度<br><code>cap</code> 获取 <code>slice</code> 的容量</p></blockquote><p><code>slice</code> 的属性，这东西是什么，还需借助 <code>unsafe</code> 来探究一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line">s[<span class="number">9</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*[<span class="number">20</span>]<span class="keyword">int</span>)(unsafe.Pointer(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出如下 (<a href="https://play.golang.org/p/Z_TMWD53syD" target="_blank" rel="noopener">Go Playground</a>)：</p><blockquote><p>c00007ce90<br>10<br>20<br>[0 0 100 0 0 0 0 0 0 200 0 0 0 0 0 0 0 0 0 0]</p></blockquote><p>这段输出除了第一个，剩余三个好像都能看出点什么， <code>10</code> 不是创建 <code>slice</code> 的长度吗，<code>20</code> 不就是指定的容量吗， 最后这个看起来有点像 <code>slice</code> 里面的数据，但是数量貌似有点多，从第三个元素和第十个元素来看，正好是给 <code>slice</code> 索引 <code>2</code> 和 <code>10</code> 指定的值，但是切片不是长度是 <code>10</code> 个吗，难道这个是容量，容量刚好是 <code>20</code>个。 </p><p>第二和第三个输出很好弄明白，就是 <code>slice</code> 的长度和容量， 最后一个其实是 <code>slice</code> 引用底层数组的数据，因为创建容量为 <code>20</code>，所以底层数组的长度就是 <code>20</code>，从这里了解到切片是引用底层数组上的一段数据，底层数组的长度就是 <code>slice</code> 的容量，由于数组长度不可变的特性，当 <code>slice</code> 的长度达到容量大小之后就需要考虑扩容，不是说数组长度不能变吗，那 <code>slice</code> 怎么实现扩容呢， 其实就是在内存上分配一个更大的数组，把当前数组上的内容拷贝到新的数组上， <code>slice</code> 来引用新的数组，这样就实现扩容了。</p><p>说了这么多，还是没有看出来 <code>slice</code> 是如何引用数组的，额…… 之前的程序还有一个输出没有搞懂是什么，难道这个就是底层数组的引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr[<span class="number">7</span>] = <span class="number">100</span></span><br><span class="line">arr[<span class="number">9</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">s1 := arr[:]</span><br><span class="line">s2 := arr[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">"----------s1---------"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(*(*[<span class="number">10</span>]<span class="keyword">int</span>)(unsafe.Pointer(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"----------s2---------"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s2)))</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>]))+size*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s2)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s2)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(*(*[<span class="number">8</span>]<span class="keyword">int</span>)(unsafe.Pointer(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s2)))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出如下(<a href="https://play.golang.org/p/4KgHvKClbzZ" target="_blank" rel="noopener">Go Playground</a>)：</p><blockquote><p>[1 2 3 0 0 0 0 100 0 200]<br>  ———-s1———<br>  c00001c0a0<br>  c00001c0a0<br>  10<br>  10<br>  [1 2 3 0 0 0 0 100 0 200]<br>  [1 2 3 0 0 0 0 100 0 200]<br>  ———-s2———<br>  c00001c0b0<br>  c00001c0b0<br>  6<br>  8<br>  [3 0 0 0 0 100]<br>[3 0 0 0 0 100 0 200]</p></blockquote><p>这段输出看起来有点小复杂，第一行输出就不用说了吧，这个是打印整个数组的数据。先分析一下 <code>s1</code> 变量的下面的输出吧，<code>s1 := arr[:]</code> 引用了整个数组，所以在第5、6行输出都是10，因为数组长度为10，所有 <code>s1</code> 的长度和容量都为10，那第3、4行输出是什么呢，他们怎么都一样呢，之前分析数组的时候 通过 <code>uintptr(unsafe.Pointer(&amp;arr[0]))</code> 来获取数组起始位置的指针的，那么第4行打印的就是数组的指针，这么就了解了第三行输出的是上面了吧，就是数组起始位置的指针，所以 <code>*(*uintptr)(unsafe.Pointer(&amp;s1))</code> 获取的就是引用数组的指针，但是这个并不是数组起始位置的指针，而是 <code>slice</code> 引用数组元素的指针，为什么这么说呢？</p><p>接着看 <code>s2</code> 变量下面的输出吧，<code>s2 := arr[2:8]</code> 引用数组第3~8的元素，那么 <code>s2</code> 的长度就是 6。 根据经验可以知道 <code>s2</code> 变量输出下面第3行就是 <code>slice</code> 的长度，但是为啥第4行是 <code>8</code> 呢，<code>slice</code> 应用数组的指定索引起始位置到数组结尾就是 <code>slice</code> 的容量， 所以 所以从第3个位置到末尾，就是8个容量。在看第1行和第2行的输出，之前分析数组的时候通过 <code>uintptr(unsafe.Pointer(&amp;arr[0]))+size*2</code> 来获取数组指定索引位置的指针，那么这段第2行就是数组索引为2的元素指针，<code>*(*uintptr)(unsafe.Pointer(&amp;s2))</code> 是获取切片的指针，第1行和第2行输出一致，所以 <code>slice</code> 实际是引用数组元素位置的指针，并不是数组起始位置的指针。</p><p><strong> 总结：</strong></p><ul><li><code>slice</code> 是的起始位置是引用数组元素位置的指针。</li><li><code>slice</code> 的长度是引用数组元素起始位置到结束位置的长度。</li><li><code>slice</code> 的容量是引用数组元素起始位置到数组末尾的长度。</li></ul><p>经过上面一轮分析了解到 <code>slice</code> 有三个属性，引用数组元素位置指针、长度和容量。实际上 <code>slice</code> 的结构像下图一样：</p><p><img src="/assets/image/20190111/slice_1.jpg" alt="slice"></p><h2 id="slice-增长"><a href="#slice-增长" class="headerlink" title="slice 增长"></a>slice 增长</h2><p><code>slice</code> 是如何增长的，用 <code>unsafe</code> 分析一下看看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用底层的数组地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用底层的数组地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用底层的数组地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出(<a href="https://play.golang.org/p/3c4ek4-0ft5" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>c000082e90<br>  9 10<br>  c000082e90<br>  10 10<br>  c00009a000<br>11 20</p></blockquote><p>从结果上看前两次地址是一样的，初始化一个长度为9，容量为10的 <code>slice</code>，当第一次 <code>append</code> 的时候容量是足够的，所以底层引用数组地址未发生变化，此时 <code>slice</code> 的长度和容量都为10，之后再次 <code>append</code> 的时候发现底层数组的地址不一样了，因为 <code>slice</code> 的长度超过了容量，但是新的 <code>slice</code> 容量并不是11而是20，这要说 <code>slice</code> 的机制了，因为数组长度不可变，想扩容 <code>slice</code>就必须分配一个更大的数组，并把之前的数据拷贝到新数组，如果一次只增加1个长度，那就会那发生大量的内存分配和数据拷贝，这个成本是很大的，所以 <code>slice</code> 是有一个增长策略的。</p><p><code>Go</code> 标准库 <code>runtime/slice.go</code> 当中有详细的 <code>slice</code> 增长策略的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新的容量，核心算法用来决定slice容量增长</span></span><br><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据et.size调整新的容量</span></span><br><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line"><span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)  <span class="comment">// 分配新的内存</span></span><br><span class="line">memmove(p, old.array, lenmem) <span class="comment">// 拷贝数据</span></span><br><span class="line">memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = mallocgc(capmem, et, <span class="literal">true</span>) <span class="comment">// 分配新的内存</span></span><br><span class="line"><span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">memmove(p, old.array, lenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">typedmemmove(et, add(p, i), add(old.array, i)) <span class="comment">// 拷贝数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125; <span class="comment">// 新slice引用新的数组，长度为旧数组的长度，容量为新数组的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本呢就三个步骤，计算新的容量、分配新的数组、拷贝数据到新数组，社区很多人分享 <code>slice</code> 的增长方法，实际都不是很精确，因为大家只分析了计算 <code>newcap</code> 的那一段，也就是上面注释的第一部分，下面的 <code>switch</code> 根据 <code>et.size</code> 来调整 <code>newcap</code> 一段被直接忽略，社区的结论是：”如果 <code>selic</code> 的容量小于1024个元素，那么扩容的时候 <code>slice</code> 的 <code>cap</code> 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一” 大多数情况也确实如此，但是根据 <code>newcap</code> 的计算规则，如果新的容量超过旧的容量2倍时会直接按新的容量分配，真的是这样吗?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出(<a href="https://play.golang.org/p/x8kN4V5R7YW" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>10 10<br>50 52</p></blockquote><p>这个结果有点出人意料， 如果是2倍增长应该是 <code>10 * 2 * 2 * 2</code> 结果应该是80， 如果说新的容量高于旧容量的两倍但结果也不是50，实际上 <code>newcap</code> 的结果就是50，那段逻辑很好理解，但是<code>switch</code> 根据 <code>et.size</code> 来调整 <code>newcap</code> 后就是52了，这段逻辑走到了 <code>case et.size == sys.PtrSize</code> 这段，详细的以后做源码分析再说。</p><p><strong> 总结 </strong></p><ul><li>当 <code>slice</code> 的长度超过其容量，会分配新的数组，并把旧数组上的值拷贝到新的数组</li><li>逐个元素添加到 <code>slice</code> 并操过其容量， 如果 <code>selic</code> 的容量小于1024个元素，那么扩容的时候 <code>slice</code> 的 <code>cap</code> 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。</li><li>批量添加元素，当新的容量高于旧容量的两倍，就会分配比新容量稍大一些，并不会按上面第二条的规则扩容。</li><li>当 <code>slice</code> 发生扩容，引用新数组后，<code>slice</code> 操作不会再影响旧的数组，而是新的数组（社区经常讨论的传递 <code>slice</code> 容量超出后，修改数据不会作用到旧的数据上），所以往往设计函数如果会对长度调整都会返回新的 <code>slice</code>，例如 <code>append</code> 方法。</li></ul><h2 id="slice-是引用类型？"><a href="#slice-是引用类型？" class="headerlink" title="slice 是引用类型？"></a>slice 是引用类型？</h2><p><code>slice</code> 不发生扩容，所有的修改都会作用在原数组上，那如果把 <code>slice</code> 传递给一个函数或者赋值给另一个变量会发生什么呢，<code>slice</code> 是引用类型，会有新的内存被分配吗。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">slice(s)</span><br><span class="line"></span><br><span class="line">s1 := s</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s1)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"-"</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)) = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"-"</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">s2 := s</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子(<a href="https://play.golang.org/p/98NZEDdh0Mm" target="_blank" rel="noopener">Go Playground</a>)比较长就不逐一分析了，在这个例子里面调用函数传递 <code>slice</code> 其变量的地址发生了变化， 但是引用数组的地址，<code>slice</code> 的长度和容量都没有变化， 这说明是对 <code>slice</code> 的浅拷贝，拷贝 <code>slice</code> 的三个属性创建一个新的变量，虽然引用底层数组还是一个，但是变量并不是一个。</p><p>第二个创建 <code>s1</code> 变量，使用 <code>s</code> 为其赋值，发现 <code>s1</code> 和函数调用一样也是 <code>s</code> 的浅拷贝，之后修改 <code>s1</code> 的长度发现 <code>s1</code> 的长度发生变化，但是 <code>s</code> 的长度保持不变， 这也说明 <code>s1</code> 就是 <code>s</code> 的浅拷贝。</p><p>这样设计有什么优势呢，第三步创建 <code>s2</code> 变量， 并且 <code>append</code> 一个元素， 发现 <code>s2</code> 的长度发生变化了， <code>s</code> 并没有，虽然这个数据就在底层数组上，但是用常规的方法 <code>s</code> 是看不到第11个位置上的数据的， <code>s1</code> 因为长度覆盖到第11个元素，所有能够看到这个数据的变化。这里能看到采用浅拷贝的方式可以使得切片的属性各自独立，而不会相互影响，这样可以有一定的隔离性，缺点也很明显，如果两个变量都引用同一个数组，同时 <code>append</code>， 在不发生扩容的情况下，总是最后一个 <code>append</code> 的结果被保留，可能引起一些编程上疑惑。</p><p><strong> 总结 </strong></p><p><code>slice</code> 是引用类型，但是和 <code>C</code> 传引用是有区别的， <code>C</code> 里面的传引用是在编译器对原变量数据引用， 并不会发生内存分配，而 <code>Go</code> 里面的引用类型传递和赋值会进行浅拷贝，在32位平台上有12个字节的内存分配， 在64位上有24字节的内存分配。</p><p><strong><em> 传引用和引用类型是有区别的， <code>slice</code> 是引用类型。</em></strong> </p><h2 id="slice-的三种状态"><a href="#slice-的三种状态" class="headerlink" title="slice 的三种状态"></a>slice 的三种状态</h2><p><code>slice</code> 有三种状态：零切片、空切片、nil切片。</p><h4 id="零切片"><a href="#零切片" class="headerlink" title="零切片"></a>零切片</h4><p>所有的类型都有零值，如果 <code>slice</code> 所引用数组元素都没有赋值，就是所有元素都是类型零值，那这就是零切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">make</span>([]*<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出(<a href="https://play.golang.org/p/RWJv8t6goas" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>[0 0 0 0 0 0 0 0 0 0]<br> [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]<br>[         ]</nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></p></blockquote><p>零切片很好理解，数组元素都为类型零值即为零切片，这种状态下的 <code>slice</code> 和正常的 <code>slice</code> 操作没有任何区别。</p><h4 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h4><p>空切片可以理解就是切片的长度为0，就是说 <code>slice</code> 没有元素。 社区大多数解释空切片为引用底层数组为 <code>zerobase</code> 这个特殊的指针。但是从操作上看空切片所有的表现就是切片长度为0，如果容量也为零底层数组就会指向 <code>zerobase</code> ，这样就不会发生内存分配， 如果容量不会零就会指向底层数据，会有内存分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">s4 := arr[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s1--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s1 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s2--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)))</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(s2 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s3--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s3)))</span><br><span class="line">fmt.Println(s3)</span><br><span class="line">fmt.Println(s3 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s4--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4)))</span><br><span class="line">fmt.Println(s4)</span><br><span class="line">fmt.Println(s4 == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出(<a href="https://play.golang.org/p/I145ObQ32yG" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>–s—-s—-s—-s—-s—-s—-s—-s—-s—-s–<br> {0 0 0}<br> []<br> –s1—-s1—-s1—-s1—-s1—-s1—-s1—-s1—-s1—-s1–<br> {18349960 0 0}<br> []<br> –s2—-s2—-s2—-s2—-s2—-s2—-s2—-s2—-s2—-s2–<br> {18349960 0 0}<br> []<br> –s3—-s3—-s3—-s3—-s3—-s3—-s3—-s3—-s3—-s3–<br> {824634269696 0 100}<br> []<br> –s4—-s4—-s4—-s4—-s4—-s4—-s4—-s4—-s4—-s4–<br> {824633835680 0 10}<br>[]</p></blockquote><p>以上示例中除了 <code>s</code> 其它的 <code>slice</code> 都是空切片，打印出来全部都是 <code>[]</code>，<code>s</code> 是nil切片下一小节说。要注意 <code>s1</code> 和 <code>s2</code> 的长度和容量都为0，且引用数组指针都是 <code>18349960</code>， 这点太重要了，因为他们都指向 <code>zerobase</code> 这个特殊的指针，是没有内存分配的。</p><p><img src="/assets/image/20190111/slice_3.jpg" alt="slice"></p><h4 id="nil切片"><a href="#nil切片" class="headerlink" title="nil切片"></a>nil切片</h4><p>什么是nil切片，这个名字说明nil切片没有引用任何底层数组，底层数组的地址为nil就是nil切片。上一小节中的 <code>s</code> 就是一个nil切片，它的底层数组指针为0，代表是一个 <code>nil</code> 指针。</p><p><img src="/assets/image/20190111/slice_2.jpg" alt="slice"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>零切片就是其元素值都是元素类型的零值的切片。<br>空切片就是数组指针不为nil，且 <code>slice</code> 的长度为0。<br>nil切片就是引用底层数组指针为 <code>nil</code> 的 <code>slice</code>。</p><p>操作上零切片、空切片和正常的切片都没有任何区别，但是nil切片会多两个特性，一个nil切片等于 <code>nil</code> 值，且进行 <code>json</code> 序列化时其值为 <code>null</code>，nil切片还可以通过赋值为 <code>nil</code> 获得。</p><h2 id="数组与-slice-大比拼"><a href="#数组与-slice-大比拼" class="headerlink" title="数组与 slice 大比拼"></a>数组与 slice 大比拼</h2><p>对数组和 <code>slice</code> 做了性能测试，源码在 <a href="https://github.com/thinkeridea/example/blob/master/array_slice/test/branch_test.go" target="_blank" rel="noopener">GitHub</a>。</p><p>对不同容量和数组和切片做性能测试，代码如下，分为：100、1000、10000、100000、1000000、10000000<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice100</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">s[i] = <span class="number">1</span> + i</span><br><span class="line">_ = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray100</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">a := [<span class="number">100</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">a[i] = <span class="number">1</span> + i</span><br><span class="line">_ = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果如下：</p><blockquote><p>goos: darwin<br> goarch: amd64<br> pkg: github.com/thinkeridea/example/array_slice/test<br> BenchmarkSlice100-8             20000000            69.8 ns/op           0 B/op           0 allocs/op<br> BenchmarkArray100-8             20000000            69.0 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice1000-8             5000000           318 ns/op           0 B/op           0 allocs/op<br> BenchmarkArray1000-8             5000000           316 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice10000-8             200000          9024 ns/op       81920 B/op           1 allocs/op<br> BenchmarkArray10000-8             500000          3143 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice100000-8             10000        114398 ns/op      802816 B/op           1 allocs/op<br> BenchmarkArray100000-8             20000         61856 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice1000000-8             2000        927946 ns/op     8003584 B/op           1 allocs/op<br> BenchmarkArray1000000-8             5000        342442 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice10000000-8             100      10555770 ns/op    80003072 B/op           1 allocs/op<br> BenchmarkArray10000000-8              50      22918998 ns/op    80003072 B/op           1 allocs/op<br> PASS<br>ok      github.com/thinkeridea/example/array_slice/test    23.333s</p></blockquote><p>从上面的结果可以发现数组和 <code>slice</code> 在1000以内的容量上时性能机会一致，而且都没有内存分配，这应该是编译器对 <code>slice</code> 的特殊优化。<br>从10000~1000000容量时数组的效率就比<code>slice</code>好了一倍有余，主要原因是数组在没有内存分配做了编译优化，而 <code>slice</code> 有内存分配。<br>但是10000000容量往后数组性能大幅度下降，<code>slice</code> 是数组性能的两倍，两个都在运行时做了内存分配，其实这么大的数组还真是不常见，也没有比较做编译器优化了。</p><h2 id="slice-与数组的应用场景总结"><a href="#slice-与数组的应用场景总结" class="headerlink" title="slice 与数组的应用场景总结"></a>slice 与数组的应用场景总结</h2><p><code>slice</code> 和数组有些差别，特别是应用层上，特性差别很大，那什么时间使用数组，什么时间使用切片呢。<br>之前做了性能测试，在1000以内性能几乎一致，只有10000~1000000时才会出现数组性能好于 <code>slice</code>，由于数组在编译时确定长度，也就是再编写程序时必须确认长度，所有往常不会用到更大的数组，大多数都在1000以内的长度。我认为如果在编写程序是就已经确定数据长度，建议用数组，而且竟可能是局部使用的位置建议用数组（避免传递产生值拷贝），比如一天24小时，一小时60分钟，ip是4个 <code>byte</code>这种情况是可以用时数组的。</p><p>为什么推荐用数组，只要能在编写程序是确定数据长度我都会用数组，因为其类型会帮助阅读理解程序，<code>dayHour := [24]Data</code> 一眼就知道是按小时切分数据存储的，如要传递数组时可以考虑传递数组的指针，当然会带来一些操作不方便，往常我使用数组都是不需要传递给其它函数的，可能会在 <code>struct</code> 里面保存数组，然后传递 <code>struct</code> 的指针，或者用 <code>unsafe</code> 来反解析数组指针到新的数组，也不会产生数据拷贝，并且只增加一句转换语句。<code>slice</code> 会比数组多存储三个 <code>int</code> 的属性，而且指针引用会增加 <code>GC</code> 扫描的成本，每次传递都会对这三个属性进行拷贝，如果可以也可以考虑传递 <code>slice</code> 的指针，指针只有一个 <code>int</code> 的大小。</p><p><strong> 对于不确定大小的数据只能用 <code>slice</code>，否则就要自己做扩容很麻烦， 对于确定大小的集合建议使用数组。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;array&lt;/code&gt; 和 &lt;code&gt;slice&lt;/code&gt; 看似相似，却有着极大的不同，但他们之间还有着千次万缕的联系 &lt;code&gt;slice&lt;/code&gt; 是引用类型、是 &lt;code&gt;array&lt;/code&gt; 的引用，相当于动态数组，&lt;br&gt;这些都是 &lt;code&gt;slice&lt;/code&gt; 的特性，但是 &lt;code&gt;slice&lt;/code&gt; 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 &lt;code&gt;slice&lt;/code&gt; 的情况下，怎样可以高效使用 &lt;code&gt;slice&lt;/code&gt;？&lt;br&gt;今天借助 &lt;code&gt;Go&lt;/code&gt; 的 &lt;code&gt;unsafe&lt;/code&gt; 包来探索 &lt;code&gt;array&lt;/code&gt; 和 &lt;code&gt;slice&lt;/code&gt; 的各种奥妙。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="https://blog.thinkeridea.com/categories/go/"/>
    
    
      <category term="slice" scheme="https://blog.thinkeridea.com/tags/slice/"/>
    
      <category term="array" scheme="https://blog.thinkeridea.com/tags/array/"/>
    
      <category term="unsafe" scheme="https://blog.thinkeridea.com/tags/unsafe/"/>
    
  </entry>
  
  <entry>
    <title>【Go】一次读锁重入导致的死锁故障</title>
    <link href="https://blog.thinkeridea.com/201812/go/yi_ci_du_suo_chong_ru_dao_zhi_de_si_suo_gu_zhang.html"/>
    <id>https://blog.thinkeridea.com/201812/go/yi_ci_du_suo_chong_ru_dao_zhi_de_si_suo_gu_zhang.html</id>
    <published>2018-12-25T14:30:10.000Z</published>
    <updated>2019-01-12T14:47:24.523Z</updated>
    
    <content type="html"><![CDATA[<p>在两天前第一次遇到自己的程序出现死锁， 我一直非常的小心使用锁，了解死锁导致的各种可能性，<br>这次的经历让我未来会更加小心，下面来回顾一下死锁发生的过程与代码演进的过程吧。</p><h2 id="简述业务背景及代码演进过程"><a href="#简述业务背景及代码演进过程" class="headerlink" title="简述业务背景及代码演进过程"></a>简述业务背景及代码演进过程</h2><p>我的程序中有一块缓存，数据会组织好放到内存中，会根据数据源（MySQL）更新而刷新缓存，是读多写少的应用场景。<br>内存中有一个很大数据列表，缓存模块会按数据维度进行分组，每次访问根据维度查找到这个列表里面的所有数据。<br>业务模块拿到数据后会根据业务需要再做一次筛选，选出N个符合条件的数据（具体多少个由业务模块的规则决定）。</p><a id="more"></a><p>以下是简化的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">data []<span class="keyword">int</span> <span class="comment">// 实际数据比这个复杂很多有很多维度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">c.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数据， 简单写一个筛选过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.data &#123;</span><br><span class="line"><span class="keyword">if</span> c.data[i] &gt; <span class="number">10</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, c.data[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回的数据会很多，可实际业务需要的数据只有几个而已，那做一个优化吧，利用 <code>go</code> 的 <code>chan</code> 实现一个迭代生成器，每次只返回一个数据，业务端找到需要的数据后立即终止。</p><p>调整后的方法大致像下面这样:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">data []<span class="keyword">int</span> <span class="comment">// 实际数据比这个复杂很多有很多维度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(next <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数据， 简单写一个筛选过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.data &#123;</span><br><span class="line"><span class="keyword">if</span> c.data[i] &gt; <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">ch &lt;- i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := &lt;-next; !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用端的代码类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">c := Cache&#123;&#125;</span><br><span class="line">next := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.Get(next) &#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, i)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(next)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调整后查看程序的内存分配显著降低，而且平安无事在生产环境运行了半个月^_^，当然截止当前还不会出现死锁的情况。<br>有一天业务调整了，在 <code>cache</code> 模块有另外一个方法，公用这个锁（实际我缓存模块为了统一，都使用一个锁，方便管理），下面的代码也写到这个 <code>cache</code> 组件里面。</p><p>以下代码只增加了改变的部分，<code>....</code> 保持原来的代码不变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">....</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">XX</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">c.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>  i &gt;c.x &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>添加一个方法怎么就导致死锁了呢，主要是调用端的业务代码也发生变化了，更改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">c := Cache&#123;&#125;</span><br><span class="line">next := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.Get(next) &#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, i)</span><br><span class="line">    <span class="keyword">if</span> c.XX(i) != i  &#123; <span class="comment">// 在这里调用了缓存模块的另一个方法</span></span><br><span class="line">        <span class="built_in">close</span>(next)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码上线存活了5天就挂了，实际是当时业务订单需求很少，只是有很多流量请求，并没有频繁访问这个方法，否者会在极短的时间导致死锁，<br>通过这块简化的代码，也很难分析出会导致死锁，真实的业务代码很多，而且调用关系比较复杂，我们通过代码审核并没有发现任何问题。</p><h2 id="事故现场分析排查问题"><a href="#事故现场分析排查问题" class="headerlink" title="事故现场分析排查问题"></a>事故现场分析排查问题</h2><p>上线5天后突然接到服务无法响应的报警，事故发生立即查看了 <code>grafana</code> 的监控数据，发现在极段时间内服务器资源消耗极速增长，然后就立即没有响应了</p><p><img src="/assets/image/20181225/20181219-011353.jpg" alt=""></p><p>通过业务监控发现服务在极端的时间打开近10万个 <code>goroutine</code> 之后持续了很长一段时间，<br><code>cpu</code> 占用和 <code>gc</code> 都很正常， 内存方面可以看出短时间内分配了很多内存，但是没有被释放，<code>gc</code> 没法回收说明一直被占用，</p><p>看到这里我心里在想可能是有个 <code>goroutine</code> 因为什么原因导致无法结束造成的事故吧，<br>然后我再往下看（实际页面是在需要滚动屏幕，第一屏只显示了上面6个模块），发现 open files 和 <code>goroutine</code> 的情况一致，并且之后的数据突然中断，<br>中断是因为服务无法影响，也就无法采集服务的信息了。</p><p><img src="/assets/image/20181225/openfd.jpg" alt=""></p><p><code>goroutine</code> 并不会占用 open files，一个http服务导致这种情况大概只能是网络连接过多，我们遭受攻击了吗……<br>显然是没有的不然cpu不能很正常，那就是有可能请求无法响应，什么原因导致呢？</p><p>使用 <code>lsof -n | grep dsp | wc -l</code> 命令去服务器查找服务打开文件数，确实在六万五千多，<br>通过 <code>cat /proc/30717/limits</code> 发现 <code>Max open files            65535                65535                files</code>，<br>配置的最大打开文件数只有 65535，使用 <code>lsof -n | grep dsp |grep TCP | wc -l</code> 发现数据和之前接近，只小了几个，那是日志文件占用的。</p><p>查看日志发现大量 <code>http: Accept error: accept tcp 172.17.191.231:8090: accept4: too many open files; retrying in 1s</code> 错误。</p><p>这些数据帮助我快速定位确实是有请求发送到服务器，服务器无法响应导致短时间内占用很多文件打开数，导致系统限制无法建立新的连接。<br>这里要说一下，即使客户端断开连接了，服务器连接还是没有办法关闭，因为 <code>goroutine</code> 没有办法关闭， 除非自己退出。</p><p>找到原因了，服务没法响应，没法通过现场查找问题了，先重新启动一下服务，恢复业务在查找代码问题。</p><p>接下来就是查找代码问题了，期间又出现了一次故障，立即重启服务，恢复业务。</p><h2 id="分析解决问题"><a href="#分析解决问题" class="headerlink" title="分析解决问题"></a>分析解决问题</h2><p>通过几个小时分析代码逻辑，终于有了进展，发现上面的示例代码逻辑块导致读锁重入，存在死锁风险，这种死锁的碰撞概率非常低，<br>之前说过我们的缓存是读多写少的场景，如果只是读取数据，上面的代码不会有任何问题，我们一天刷新缓存的次数也不过百余次而已。</p><p>看一下究竟发生了什么导致的死锁吧：</p><ul><li>程序执行 <code>cache.Get</code> 获取一个 <code>chan</code>, 在 <code>cache.Get</code> 里面有一个 <code>goroutine</code> 读取数据只有加了读写锁，只有 <code>goroutine</code> 关闭才会释放</li><li><code>for i := range c.Get(next) {</code> 遍历 <code>chan</code> 时 <code>goroutine</code> 不会结束，也就说读锁没有被释放</li><li>遍历时执行了 <code>c.XX(i)</code> 方法，在该方面里面也加了读锁， 形成了读锁重入的场景，但是该放执行周期很短，执行完就会马上释放</li></ul><p>好吧，这样的流程并没有形成死锁，什么情况下导致的死锁呢，接着看一下一个场景：</p><ul><li>程序执行 <code>cache.Get</code> 获取一个 <code>chan</code>, 在 <code>cache.Get</code> 里面有一个 <code>goroutine</code> 读取数据只有加了读写锁，只有 <code>goroutine</code> 关闭才会释放</li><li><code>for i := range c.Get(next) {</code> 遍历 <code>chan</code> 时 <code>goroutine</code> 不会结束，也就说读锁没有被释放</li><li>数据发生了改变，触发了缓存刷新，申请独占锁（写锁），等待所有读锁释放</li><li>遍历时执行 <code>c.XX(i)</code> 方法，该方法申请读锁，因为写锁在等待，所以任何读锁都将等待写锁释放后才能添加成功</li><li>for 循环被阻塞， <code>cache.Get</code> 里面的 <code>goroutine</code> 无法退出，无法释放读锁</li><li>写锁等待所有读锁释放</li><li><code>c.XX(i)</code> 等待写锁释放</li><li>….</li></ul><p>重点看第三步，这里是关键，因为在两个嵌套的读锁中间申请写锁，导致死锁发生，找到原因修复起来很简单的，</p><p>调整 <code>cache.Get</code> 加锁的方法，把 <code>c.data</code> 赋值给一个临时变量 <code>data</code>, 在这段代码前后加锁和释放锁，锁的代码块更小，时间更短</p><p><code>c.data</code> 单独拷贝是安全的，那怕是指针数据，因为每次刷新缓存都会给 <code>c.data</code> 重新赋值，分配新的内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">data []<span class="keyword">int</span> <span class="comment">// 实际数据比这个复杂很多有很多维度</span></span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">XX</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    c.lock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>  i &gt;c.x &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(next <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">c.lock.RLock()</span><br><span class="line">data := c.data</span><br><span class="line">c.lock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数据， 简单写一个筛选过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] &gt; <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">ch &lt;- i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := &lt;-next; !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复之后的业务状态：</p><p><img src="/assets/image/20181225/20181219-011418.jpg" alt=""></p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>用程序复现一下上面的场景可以吗，好像有点难，我写了一个简单的复现代码，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = sync.RWMutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.RLock() <span class="comment">// 读锁1</span></span><br><span class="line"><span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">fmt.Println(<span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="number">2</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">fmt.Println(<span class="number">3</span>)</span><br><span class="line">b()</span><br><span class="line">fmt.Println(<span class="number">4</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">5</span>)</span><br><span class="line">&lt;-c</span><br><span class="line">fmt.Println(<span class="number">6</span>)</span><br><span class="line">l.Lock()</span><br><span class="line">fmt.Println(<span class="number">7</span>)</span><br><span class="line">fmt.Println(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">defer</span> l.Unlock()</span><br><span class="line">fmt.Println(<span class="number">9</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">10</span>)</span><br><span class="line">l.RLock() <span class="comment">// 读锁2</span></span><br><span class="line">fmt.Println(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">fmt.Println(<span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出(受 <code>goroutine</code> 运行时影响在输出数字3之前会有些许差异)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>分析一下这个运行流程吧:</p><ul><li>首先加上读锁1，就是 <code>fmt.Println(1)</code> 之前， 状态加读锁1</li><li>另外一个 <code>goroutine</code> 启动，<code>fmt.Println(5)</code>， 状态加读锁1</li><li>发送数据 <code>c &lt;- 1</code> ， 状态加读锁1</li><li>接受到数据 <code>&lt;-c</code> <code>fmt.Println(6)</code>， 状态加读锁1</li><li>输出 2 <code>fmt.Println(2)</code>， 状态加读锁1</li><li>暂停当前 <code>goroutine</code> <code>runtime.Gosched()</code> ， 状态加读锁1</li><li>申请写锁 <code>l.Lock()</code>， 等待读锁1释放， 状态加读锁1、写锁等待</li><li>切换 <code>goroutine</code> 执行 <code>fmt.Println(3)</code> 与 <code>b()</code>， 状态加读锁1、写锁等待</li><li>输出10 <code>fmt.Println(10)</code>， 申请读锁2，等待写锁释放， 状态加读锁1、写锁等待、读锁2等待</li><li>支持程序永久阻塞……</li></ul><h2 id="分析读写锁实现"><a href="#分析读写锁实现" class="headerlink" title="分析读写锁实现"></a>分析读写锁实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请写锁时会在 <code>rw.readerCount</code> 读数量变量上自增加 1，如果结果小于 0，当前读锁进入修改等待读锁唤醒信号，<br>单独看着一个方法会比较懵，为啥读的数量会小于0呢，接着看写锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">rw.w.Lock()</span><br><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// Wait for active readers.</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请写锁时会先加上互斥锁，也就是有其它写的客户端的话会等待写锁释放才能加上，具体实现看互斥锁的代码，<br>然后在 <code>rw.readerCount</code> 上自增一个极大的负数 <code>1 &lt;&lt; 30</code> ， 读写锁这里也就限制了我们的同时读的进程不能超过这个值。<br>然后在结果上加上 <code>rwmutexMaxReaders</code> 也就是 <code>atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</code> 得到实际读客户端的数量<br>如果读的客户端不等于0，就在 <code>rw.readerWait</code> 自增读客户端的数量，之后陷入睡眠，等待 <code>rw.writerSem</code> 唤醒。</p><p>分析了这两段代码我们就能明白，写锁等待或者添加时，读锁没法添加上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A writer is pending.</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放读锁，先在 <code>rw.readerCount</code> 减 1，然后检查读客户端是否小于0，如果小于0说明有写锁在等待，<br>在 <code>rw.readerWait</code> 上减1，这个变量记录的是写等待读客户端的数量，如果没有需要等待的读客户端了，就通知 <code>rw.writerSem</code> 唤醒写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">rw.w.Unlock()</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁在释放时会给 <code>rw.readerCount</code> 自增 <code>rwmutexMaxReaders</code> 还原真实读客户端数量。<br><code>for i := 0; i &lt; int(r); i++ {</code> 用来唤醒所有的读客户端，因为在写锁的时候，申请读锁的客户端会被计数，但是都会陷入睡眠状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以前特别强调过读锁重入导致死锁的问题，而且这个问题非常难在业务代码里面复现，触发几率很低，<br>编译和运行时都无法检测这种情况，所以千万不能陷入读锁重入的嵌套使用的情况，否者问题非常难以排查。</p><p>关于加锁的几个小经验：</p><ul><li>运行时离开当前逻辑就释放锁。</li><li>锁的粒度越小越好，加锁后尽快释放锁。</li><li>尽量不用 <code>defer</code> 释放锁。</li><li>读锁不要嵌套。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在两天前第一次遇到自己的程序出现死锁， 我一直非常的小心使用锁，了解死锁导致的各种可能性，&lt;br&gt;这次的经历让我未来会更加小心，下面来回顾一下死锁发生的过程与代码演进的过程吧。&lt;/p&gt;
&lt;h2 id=&quot;简述业务背景及代码演进过程&quot;&gt;&lt;a href=&quot;#简述业务背景及代码演进过程&quot; class=&quot;headerlink&quot; title=&quot;简述业务背景及代码演进过程&quot;&gt;&lt;/a&gt;简述业务背景及代码演进过程&lt;/h2&gt;&lt;p&gt;我的程序中有一块缓存，数据会组织好放到内存中，会根据数据源（MySQL）更新而刷新缓存，是读多写少的应用场景。&lt;br&gt;内存中有一个很大数据列表，缓存模块会按数据维度进行分组，每次访问根据维度查找到这个列表里面的所有数据。&lt;br&gt;业务模块拿到数据后会根据业务需要再做一次筛选，选出N个符合条件的数据（具体多少个由业务模块的规则决定）。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="https://blog.thinkeridea.com/categories/go/"/>
    
    
      <category term="读写锁" scheme="https://blog.thinkeridea.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
      <category term="死锁" scheme="https://blog.thinkeridea.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
</feed>
