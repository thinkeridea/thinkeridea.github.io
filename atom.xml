<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thinkeridea博客</title>
  <icon>https://www.gravatar.com/avatar/9d6f60998913bb76135b4779bbb90154</icon>
  <subtitle>thinkeridea</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.thinkeridea.com/"/>
  <updated>2019-01-13T13:32:02.259Z</updated>
  <id>https://blog.thinkeridea.com/</id>
  
  <author>
    <name>戚银</name>
    <email>qiyin@thinkeridea.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Go】深入剖析slice和array</title>
    <link href="https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html"/>
    <id>https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html</id>
    <published>2019-01-08T03:36:26.000Z</published>
    <updated>2019-01-13T13:32:02.259Z</updated>
    
    <content type="html"><![CDATA[<p><code>array</code> 和 <code>slice</code> 看似相似，却有着极大的不同，但他们之间还有着千次万缕的联系 <code>slice</code> 是引用类型、是 <code>array</code> 的引用，相当于动态数组，<br>这些都是 <code>slice</code> 的特性，但是 <code>slice</code> 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 <code>slice</code> 的情况下，怎样可以高效使用 <code>slice</code>？<br>今天借助 <code>Go</code> 的 <code>unsafe</code> 包来探索 <code>array</code> 和 <code>slice</code> 的各种奥妙。</p><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>slice</code> 是在 <code>array</code> 的基础上实现的，需要先详细了解一下数组。</p><p><strong> 维基上如此介绍数组：</strong></p><blockquote><p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储，利用元素的索引（index）可以计算出该元素对应的存储地址。<br><strong> 数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性：</strong></p><ol><li>请求空间以后大小固定，不能再改变（数据溢出问题）；</li><li>在内存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间；</li><li>在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。</li></ol></blockquote><p>根据维基的介绍，了解到数组是存储在一段连续的内存中，每个元素的类型相同，即是每个元素的宽度相同，可以根据元素的宽度计算元素存储的位置。<br>通过这段介绍总结一下数组有一下特性：</p><ul><li>分配在连续的内存地址上</li><li>元素类型一致，元素存储宽度一致</li><li>空间大小固定，不能修改</li><li>可以通过索引计算出元素对应存储的位置（只需要知道数组内存的起始位置和数据元素宽度即可）</li><li>会出现数据溢出的问题（下标越界）</li></ul><p><code>Go</code> 中的数组如何实现的呢，恰恰就是这么实现的，实际上几乎所有计算机语言，数组的实现都是相似的，也拥有上面总结的特性。<br><code>Go</code> 语言的数组不同于 <code>C</code> 语言或者其他语言的数组，<code>C</code> 语言的数组变量是指向数组第一个元素的指针；<br>而 <code>Go</code> 语言的数组是一个值，<code>Go</code> 语言中的数组是值类型，一个数组变量就表示着整个数组，意味着 <code>Go</code> 语言的数组在传递的时候，传递的是原数组的拷贝。</p><p>在程序中数组的初始化有两种方法 <code>arr := [10]int{}</code> 或 <code>var arr  [10]int</code>，但是不能使用 <code>make</code> 来创建，数组这节结束时再探讨一下这个问题。<br>使用 <code>unsafe</code>来看一下在内存中都是如何存储的吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(unsafe.Sizeof(arr))</span><br><span class="line">size := unsafe.Sizeof(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组指定索引元素的值</span></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>])) + <span class="number">1</span>*size)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数组指定索引元素的值</span></span><br><span class="line">*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>])) + <span class="number">1</span>*size)) = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Println(arr[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出如下 (<a href="https://play.golang.org/p/3v-rAQZG-E6" target="_blank" rel="noopener">Go Playground</a>)：</p><blockquote><p>12<br>2<br>10</p></blockquote><p>首先说 <code>12</code> 是 <code>fmt.Println(unsafe.Sizeof(arr))</code> 输出的，<code>unsafe.Sizeof</code> 用来计算当前变量的值在内存中的大小，<code>12</code> 这个代表一个 <code>int</code> 有4个字节，<code>3 * 4</code> 就是 <code>12</code>。<br>这是在32位平台上运行得出的结果， 如果在64位平台上运行数组的大小是 <code>24</code>。从这里可以看出 <code>[3]int</code> 在内存中由3个连续的 <code>int</code> 类型组成，且有 <code>12</code> 个字节那么长，这就说明了数组在内存中没有存储多余的数据，只存储元素本身。</p><p><code>size := unsafe.Sizeof(arr[0])</code> 用来计算单个元素的宽度，<code>int</code>在32位平台上就是4个字节，<code>uintptr(unsafe.Pointer(&amp;arr[0]))</code> 用来计算数组起始位置的指针，<code>1*size</code> 用来获取索引为1的元素相对数组起始位置的偏移，<code>unsafe.Pointer(uintptr(unsafe.Pointer(&amp;arr[0])) + 1*size))</code> 获取索引为1的元素指针，<code>*(*int)</code> 用来转换指针位置的数据类型， 因为 <code>int</code> 是4个字节，所以只会读取4个字节的数据，由元素类型限制数据宽度，来确定元素的结束位置，因此得到的结果是 <code>2</code>。</p><p>上一个步骤获取元素的值，其中先获取了元素的指针，赋值的时候只需要对这个指针位置设置值就可以了， <code>*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;arr[0])) + 1*size)) = 10</code> 就是用来给指定下标元素赋值。</p><p><img src="/assets/image/20190111/array.jpg" alt="数组在内存中的结构"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n:= <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> arr = [n]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，动态的给数组设定长度，会导致编译错误 <code>non-constant array bound n</code>， 由此推导数组的所有操作都是编译时完成的，会转成对应的指令，通过这个特性知道数组的长度是数组类型不可或缺的一部分，并且必须在编写程序时确定。<br>可以通过 <code>GOOS=linux GOARCH=amd64 go tool compile -S array.go</code> 来获取对应的汇编代码，在 <code>array.go</code> 中做一些数组相关的操作，查看转换对应的指令。</p><p>之前的疑问，为什么数组不能用 <code>make</code> 创建？ 上面分析了解到数组操作是在编译时转换成对应指令的，而 <code>make</code> 是在运行时处理（特殊状态下会做编译器优化，make可以被优化，下面 <code>slice</code> 分析时来讲）。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>因为数组是固定长度且是值传递，很不灵活，所以在 <code>Go</code> 程序中很少看到数组的影子。然而 <code>slice</code> 无处不在，<code>slice</code> 以数组为基础，提供强大的功能和遍历性。<br><code>slice</code> 的类型规范是[]T，<code>slice</code> T元素的类型。与数组类型不同，<code>slice</code> 类型没有指定的长度。</p><p><strong> <code>slice</code> 申明的几种方法：</strong> </p><blockquote><p><code>s := []int{1, 2, 3}</code> 简短的赋值语句<br><code>var s []int</code> <code>var</code> 申明<br><code>make([]int, 3, 8)</code> 或 <code>make([]int, 3)</code> <code>make</code> 内置方法创建<br><code>s := ss[:5]</code> 从切片或者数组创建</p></blockquote><p><strong> <code>slice</code> 有两个内置函数来获取其属性：</strong></p><blockquote><p><code>len</code> 获取 <code>slice</code> 的长度<br><code>cap</code> 获取 <code>slice</code> 的容量</p></blockquote><p><code>slice</code> 的属性，这东西是什么，还需借助 <code>unsafe</code> 来探究一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line">s[<span class="number">9</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*[<span class="number">20</span>]<span class="keyword">int</span>)(unsafe.Pointer(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出如下 (<a href="https://play.golang.org/p/Z_TMWD53syD" target="_blank" rel="noopener">Go Playground</a>)：</p><blockquote><p>c00007ce90<br>10<br>20<br>[0 0 100 0 0 0 0 0 0 200 0 0 0 0 0 0 0 0 0 0]</p></blockquote><p>这段输出除了第一个，剩余三个好像都能看出点什么， <code>10</code> 不是创建 <code>slice</code> 的长度吗，<code>20</code> 不就是指定的容量吗， 最后这个看起来有点像 <code>slice</code> 里面的数据，但是数量貌似有点多，从第三个元素和第十个元素来看，正好是给 <code>slice</code> 索引 <code>2</code> 和 <code>10</code> 指定的值，但是切片不是长度是 <code>10</code> 个吗，难道这个是容量，容量刚好是 <code>20</code>个。 </p><p>第二和第三个输出很好弄明白，就是 <code>slice</code> 的长度和容量， 最后一个其实是 <code>slice</code> 引用底层数组的数据，因为创建容量为 <code>20</code>，所以底层数组的长度就是 <code>20</code>，从这里了解到切片是引用底层数组上的一段数据，底层数组的长度就是 <code>slice</code> 的容量，由于数组长度不可变的特性，当 <code>slice</code> 的长度达到容量大小之后就需要考虑扩容，不是说数组长度不能变吗，那 <code>slice</code> 怎么实现扩容呢， 其实就是在内存上分配一个更大的数组，把当前数组上的内容拷贝到新的数组上， <code>slice</code> 来引用新的数组，这样就实现扩容了。</p><p>说了这么多，还是没有看出来 <code>slice</code> 是如何引用数组的，额…… 之前的程序还有一个输出没有搞懂是什么，难道这个就是底层数组的引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr[<span class="number">7</span>] = <span class="number">100</span></span><br><span class="line">arr[<span class="number">9</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">s1 := arr[:]</span><br><span class="line">s2 := arr[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">"----------s1---------"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(*(*[<span class="number">10</span>]<span class="keyword">int</span>)(unsafe.Pointer(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"----------s2---------"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s2)))</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arr[<span class="number">0</span>]))+size*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s2)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s2)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(*(*[<span class="number">8</span>]<span class="keyword">int</span>)(unsafe.Pointer(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s2)))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出如下(<a href="https://play.golang.org/p/4KgHvKClbzZ" target="_blank" rel="noopener">Go Playground</a>)：</p><blockquote><p>[1 2 3 0 0 0 0 100 0 200]<br>  ———-s1———<br>  c00001c0a0<br>  c00001c0a0<br>  10<br>  10<br>  [1 2 3 0 0 0 0 100 0 200]<br>  [1 2 3 0 0 0 0 100 0 200]<br>  ———-s2———<br>  c00001c0b0<br>  c00001c0b0<br>  6<br>  8<br>  [3 0 0 0 0 100]<br>[3 0 0 0 0 100 0 200]</p></blockquote><p>这段输出看起来有点小复杂，第一行输出就不用说了吧，这个是打印整个数组的数据。先分析一下 <code>s1</code> 变量的下面的输出吧，<code>s1 := arr[:]</code> 引用了整个数组，所以在第5、6行输出都是10，因为数组长度为10，所有 <code>s1</code> 的长度和容量都为10，那第3、4行输出是什么呢，他们怎么都一样呢，之前分析数组的时候 通过 <code>uintptr(unsafe.Pointer(&amp;arr[0]))</code> 来获取数组起始位置的指针的，那么第4行打印的就是数组的指针，这么就了解了第三行输出的是上面了吧，就是数组起始位置的指针，所以 <code>*(*uintptr)(unsafe.Pointer(&amp;s1))</code> 获取的就是引用数组的指针，但是这个并不是数组起始位置的指针，而是 <code>slice</code> 引用数组元素的指针，为什么这么说呢？</p><p>接着看 <code>s2</code> 变量下面的输出吧，<code>s2 := arr[2:8]</code> 引用数组第3~8的元素，那么 <code>s2</code> 的长度就是 6。 根据经验可以知道 <code>s2</code> 变量输出下面第3行就是 <code>slice</code> 的长度，但是为啥第4行是 <code>8</code> 呢，<code>slice</code> 应用数组的指定索引起始位置到数组结尾就是 <code>slice</code> 的容量， 所以 所以从第3个位置到末尾，就是8个容量。在看第1行和第2行的输出，之前分析数组的时候通过 <code>uintptr(unsafe.Pointer(&amp;arr[0]))+size*2</code> 来获取数组指定索引位置的指针，那么这段第2行就是数组索引为2的元素指针，<code>*(*uintptr)(unsafe.Pointer(&amp;s2))</code> 是获取切片的指针，第1行和第2行输出一致，所以 <code>slice</code> 实际是引用数组元素位置的指针，并不是数组起始位置的指针。</p><p><strong> 总结：</strong></p><ul><li><code>slice</code> 是的起始位置是引用数组元素位置的指针。</li><li><code>slice</code> 的长度是引用数组元素起始位置到结束位置的长度。</li><li><code>slice</code> 的容量是引用数组元素起始位置到数组末尾的长度。</li></ul><p>经过上面一轮分析了解到 <code>slice</code> 有三个属性，引用数组元素位置指针、长度和容量。实际上 <code>slice</code> 的结构像下图一样：</p><p><img src="/assets/image/20190111/slice_1.jpg" alt="slice"></p><h2 id="slice-增长"><a href="#slice-增长" class="headerlink" title="slice 增长"></a>slice 增长</h2><p><code>slice</code> 是如何增长的，用 <code>unsafe</code> 分析一下看看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用底层的数组地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用底层的数组地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用底层的数组地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出(<a href="https://play.golang.org/p/3c4ek4-0ft5" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>c000082e90<br>  9 10<br>  c000082e90<br>  10 10<br>  c00009a000<br>11 20</p></blockquote><p>从结果上看前两次地址是一样的，初始化一个长度为9，容量为10的 <code>slice</code>，当第一次 <code>append</code> 的时候容量是足够的，所以底层引用数组地址未发生变化，此时 <code>slice</code> 的长度和容量都为10，之后再次 <code>append</code> 的时候发现底层数组的地址不一样了，因为 <code>slice</code> 的长度超过了容量，但是新的 <code>slice</code> 容量并不是11而是20，这要说 <code>slice</code> 的机制了，因为数组长度不可变，想扩容 <code>slice</code>就必须分配一个更大的数组，并把之前的数据拷贝到新数组，如果一次只增加1个长度，那就会那发生大量的内存分配和数据拷贝，这个成本是很大的，所以 <code>slice</code> 是有一个增长策略的。</p><p><code>Go</code> 标准库 <code>runtime/slice.go</code> 当中有详细的 <code>slice</code> 增长策略的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新的容量，核心算法用来决定slice容量增长</span></span><br><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据et.size调整新的容量</span></span><br><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line"><span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)  <span class="comment">// 分配新的内存</span></span><br><span class="line">memmove(p, old.array, lenmem) <span class="comment">// 拷贝数据</span></span><br><span class="line">memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = mallocgc(capmem, et, <span class="literal">true</span>) <span class="comment">// 分配新的内存</span></span><br><span class="line"><span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">memmove(p, old.array, lenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">typedmemmove(et, add(p, i), add(old.array, i)) <span class="comment">// 拷贝数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125; <span class="comment">// 新slice引用新的数组，长度为旧数组的长度，容量为新数组的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本呢就三个步骤，计算新的容量、分配新的数组、拷贝数据到新数组，社区很多人分享 <code>slice</code> 的增长方法，实际都不是很精确，因为大家只分析了计算 <code>newcap</code> 的那一段，也就是上面注释的第一部分，下面的 <code>switch</code> 根据 <code>et.size</code> 来调整 <code>newcap</code> 一段被直接忽略，社区的结论是：”如果 <code>selic</code> 的容量小于1024个元素，那么扩容的时候 <code>slice</code> 的 <code>cap</code> 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一” 大多数情况也确实如此，但是根据 <code>newcap</code> 的计算规则，如果新的容量超过旧的容量2倍时会直接按新的容量分配，真的是这样吗?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出(<a href="https://play.golang.org/p/x8kN4V5R7YW" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>10 10<br>50 52</p></blockquote><p>这个结果有点出人意料， 如果是2倍增长应该是 <code>10 * 2 * 2 * 2</code> 结果应该是80， 如果说新的容量高于旧容量的两倍但结果也不是50，实际上 <code>newcap</code> 的结果就是50，那段逻辑很好理解，但是<code>switch</code> 根据 <code>et.size</code> 来调整 <code>newcap</code> 后就是52了，这段逻辑走到了 <code>case et.size == sys.PtrSize</code> 这段，详细的以后做源码分析再说。</p><p><strong> 总结 </strong></p><ul><li>当 <code>slice</code> 的长度超过其容量，会分配新的数组，并把旧数组上的值拷贝到新的数组</li><li>逐个元素添加到 <code>slice</code> 并操过其容量， 如果 <code>selic</code> 的容量小于1024个元素，那么扩容的时候 <code>slice</code> 的 <code>cap</code> 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。</li><li>批量添加元素，当新的容量高于旧容量的两倍，就会分配比新容量稍大一些，并不会按上面第二条的规则扩容。</li><li>当 <code>slice</code> 发生扩容，引用新数组后，<code>slice</code> 操作不会再影响旧的数组，而是新的数组（社区经常讨论的传递 <code>slice</code> 容量超出后，修改数据不会作用到旧的数据上），所以往往设计函数如果会对长度调整都会返回新的 <code>slice</code>，例如 <code>append</code> 方法。</li></ul><h2 id="slice-是引用类型？"><a href="#slice-是引用类型？" class="headerlink" title="slice 是引用类型？"></a>slice 是引用类型？</h2><p><code>slice</code> 不发生扩容，所有的修改都会作用在原数组上，那如果把 <code>slice</code> 传递给一个函数或者赋值给另一个变量会发生什么呢，<code>slice</code> 是引用类型，会有新的内存被分配吗。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">slice(s)</span><br><span class="line"></span><br><span class="line">s1 := s</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s1)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"-"</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)) = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s1)) + size*<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"-"</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">s2 := s</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">size := unsafe.Sizeof(<span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size)))</span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + size*<span class="number">2</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子(<a href="https://play.golang.org/p/98NZEDdh0Mm" target="_blank" rel="noopener">Go Playground</a>)比较长就不逐一分析了，在这个例子里面调用函数传递 <code>slice</code> 其变量的地址发生了变化， 但是引用数组的地址，<code>slice</code> 的长度和容量都没有变化， 这说明是对 <code>slice</code> 的浅拷贝，拷贝 <code>slice</code> 的三个属性创建一个新的变量，虽然引用底层数组还是一个，但是变量并不是一个。</p><p>第二个创建 <code>s1</code> 变量，使用 <code>s</code> 为其赋值，发现 <code>s1</code> 和函数调用一样也是 <code>s</code> 的浅拷贝，之后修改 <code>s1</code> 的长度发现 <code>s1</code> 的长度发生变化，但是 <code>s</code> 的长度保持不变， 这也说明 <code>s1</code> 就是 <code>s</code> 的浅拷贝。</p><p>这样设计有什么优势呢，第三步创建 <code>s2</code> 变量， 并且 <code>append</code> 一个元素， 发现 <code>s2</code> 的长度发生变化了， <code>s</code> 并没有，虽然这个数据就在底层数组上，但是用常规的方法 <code>s</code> 是看不到第11个位置上的数据的， <code>s1</code> 因为长度覆盖到第11个元素，所有能够看到这个数据的变化。这里能看到采用浅拷贝的方式可以使得切片的属性各自独立，而不会相互影响，这样可以有一定的隔离性，缺点也很明显，如果两个变量都引用同一个数组，同时 <code>append</code>， 在不发生扩容的情况下，总是最后一个 <code>append</code> 的结果被保留，可能引起一些编程上疑惑。</p><p><strong> 总结 </strong></p><p><code>slice</code> 是引用类型，但是和 <code>C</code> 传引用是有区别的， <code>C</code> 里面的传引用是在编译器对原变量数据引用， 并不会发生内存分配，而 <code>Go</code> 里面的引用类型传递和赋值会进行浅拷贝，在32位平台上有12个字节的内存分配， 在64位上有24字节的内存分配。</p><p><strong><em> 传引用和引用类型是有区别的， <code>slice</code> 是引用类型。</em></strong> </p><h2 id="slice-的三种状态"><a href="#slice-的三种状态" class="headerlink" title="slice 的三种状态"></a>slice 的三种状态</h2><p><code>slice</code> 有三种状态：零切片、空切片、nil切片。</p><h4 id="零切片"><a href="#零切片" class="headerlink" title="零切片"></a>零切片</h4><p>所有的类型都有零值，如果 <code>slice</code> 所引用数组元素都没有赋值，就是所有元素都是类型零值，那这就是零切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">make</span>([]*<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出(<a href="https://play.golang.org/p/RWJv8t6goas" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>[0 0 0 0 0 0 0 0 0 0]<br> [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]<br>[         ]</nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></p></blockquote><p>零切片很好理解，数组元素都为类型零值即为零切片，这种状态下的 <code>slice</code> 和正常的 <code>slice</code> 操作没有任何区别。</p><h4 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h4><p>空切片可以理解就是切片的长度为0，就是说 <code>slice</code> 没有元素。 社区大多数解释空切片为引用底层数组为 <code>zerobase</code> 这个特殊的指针。但是从操作上看空切片所有的表现就是切片长度为0，如果容量也为零底层数组就会指向 <code>zerobase</code> ，这样就不会发生内存分配， 如果容量不会零就会指向底层数据，会有内存分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">s4 := arr[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s)))</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s1--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s1 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s2--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)))</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(s2 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s3--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s3)))</span><br><span class="line">fmt.Println(s3)</span><br><span class="line">fmt.Println(s3 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"--s4--"</span>, <span class="number">10</span>))</span><br><span class="line">fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4)))</span><br><span class="line">fmt.Println(s4)</span><br><span class="line">fmt.Println(s4 == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出(<a href="https://play.golang.org/p/I145ObQ32yG" target="_blank" rel="noopener">Go Playground</a>):</p><blockquote><p>–s—-s—-s—-s—-s—-s—-s—-s—-s—-s–<br> {0 0 0}<br> []<br> –s1—-s1—-s1—-s1—-s1—-s1—-s1—-s1—-s1—-s1–<br> {18349960 0 0}<br> []<br> –s2—-s2—-s2—-s2—-s2—-s2—-s2—-s2—-s2—-s2–<br> {18349960 0 0}<br> []<br> –s3—-s3—-s3—-s3—-s3—-s3—-s3—-s3—-s3—-s3–<br> {824634269696 0 100}<br> []<br> –s4—-s4—-s4—-s4—-s4—-s4—-s4—-s4—-s4—-s4–<br> {824633835680 0 10}<br>[]</p></blockquote><p>以上示例中除了 <code>s</code> 其它的 <code>slice</code> 都是空切片，打印出来全部都是 <code>[]</code>，<code>s</code> 是nil切片下一小节说。要注意 <code>s1</code> 和 <code>s2</code> 的长度和容量都为0，且引用数组指针都是 <code>18349960</code>， 这点太重要了，因为他们都指向 <code>zerobase</code> 这个特殊的指针，是没有内存分配的。</p><p><img src="/assets/image/20190111/slice_3.jpg" alt="slice"></p><h4 id="nil切片"><a href="#nil切片" class="headerlink" title="nil切片"></a>nil切片</h4><p>什么是nil切片，这个名字说明nil切片没有引用任何底层数组，底层数组的地址为nil就是nil切片。上一小节中的 <code>s</code> 就是一个nil切片，它的底层数组指针为0，代表是一个 <code>nil</code> 指针。</p><p><img src="/assets/image/20190111/slice_2.jpg" alt="slice"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>零切片就是其元素值都是元素类型的零值的切片。<br>空切片就是数组指针不为nil，且 <code>slice</code> 的长度为0。<br>nil切片就是引用底层数组指针为 <code>nil</code> 的 <code>slice</code>。</p><p>操作上零切片、空切片和正常的切片都没有任何区别，但是nil切片会多两个特性，一个nil切片等于 <code>nil</code> 值，且进行 <code>json</code> 序列化时其值为 <code>null</code>，nil切片还可以通过赋值为 <code>nil</code> 获得。</p><h2 id="数组与-slice-大比拼"><a href="#数组与-slice-大比拼" class="headerlink" title="数组与 slice 大比拼"></a>数组与 slice 大比拼</h2><p>对数组和 <code>slice</code> 做了性能测试，源码在 <a href="https://github.com/thinkeridea/example/blob/master/array_slice/test/branch_test.go" target="_blank" rel="noopener">GitHub</a>。</p><p>对不同容量和数组和切片做性能测试，代码如下，分为：100、1000、10000、100000、1000000、10000000<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice100</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">s[i] = <span class="number">1</span> + i</span><br><span class="line">_ = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray100</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">a := [<span class="number">100</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">a[i] = <span class="number">1</span> + i</span><br><span class="line">_ = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果如下：</p><blockquote><p>goos: darwin<br> goarch: amd64<br> pkg: github.com/thinkeridea/example/array_slice/test<br> BenchmarkSlice100-8             20000000            69.8 ns/op           0 B/op           0 allocs/op<br> BenchmarkArray100-8             20000000            69.0 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice1000-8             5000000           318 ns/op           0 B/op           0 allocs/op<br> BenchmarkArray1000-8             5000000           316 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice10000-8             200000          9024 ns/op       81920 B/op           1 allocs/op<br> BenchmarkArray10000-8             500000          3143 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice100000-8             10000        114398 ns/op      802816 B/op           1 allocs/op<br> BenchmarkArray100000-8             20000         61856 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice1000000-8             2000        927946 ns/op     8003584 B/op           1 allocs/op<br> BenchmarkArray1000000-8             5000        342442 ns/op           0 B/op           0 allocs/op<br> BenchmarkSlice10000000-8             100      10555770 ns/op    80003072 B/op           1 allocs/op<br> BenchmarkArray10000000-8              50      22918998 ns/op    80003072 B/op           1 allocs/op<br> PASS<br>ok      github.com/thinkeridea/example/array_slice/test    23.333s</p></blockquote><p>从上面的结果可以发现数组和 <code>slice</code> 在1000以内的容量上时性能机会一致，而且都没有内存分配，这应该是编译器对 <code>slice</code> 的特殊优化。<br>从10000~1000000容量时数组的效率就比<code>slice</code>好了一倍有余，主要原因是数组在没有内存分配做了编译优化，而 <code>slice</code> 有内存分配。<br>但是10000000容量往后数组性能大幅度下降，<code>slice</code> 是数组性能的两倍，两个都在运行时做了内存分配，其实这么大的数组还真是不常见，也没有比较做编译器优化了。</p><h2 id="slice-与数组的应用场景总结"><a href="#slice-与数组的应用场景总结" class="headerlink" title="slice 与数组的应用场景总结"></a>slice 与数组的应用场景总结</h2><p><code>slice</code> 和数组有些差别，特别是应用层上，特性差别很大，那什么时间使用数组，什么时间使用切片呢。<br>之前做了性能测试，在1000以内性能几乎一致，只有10000~1000000时才会出现数组性能好于 <code>slice</code>，由于数组在编译时确定长度，也就是再编写程序时必须确认长度，所有往常不会用到更大的数组，大多数都在1000以内的长度。我认为如果在编写程序是就已经确定数据长度，建议用数组，而且竟可能是局部使用的位置建议用数组（避免传递产生值拷贝），比如一天24小时，一小时60分钟，ip是4个 <code>byte</code>这种情况是可以用时数组的。</p><p>为什么推荐用数组，只要能在编写程序是确定数据长度我都会用数组，因为其类型会帮助阅读理解程序，<code>dayHour := [24]Data</code> 一眼就知道是按小时切分数据存储的，如要传递数组时可以考虑传递数组的指针，当然会带来一些操作不方便，往常我使用数组都是不需要传递给其它函数的，可能会在 <code>struct</code> 里面保存数组，然后传递 <code>struct</code> 的指针，或者用 <code>unsafe</code> 来反解析数组指针到新的数组，也不会产生数据拷贝，并且只增加一句转换语句。<code>slice</code> 会比数组多存储三个 <code>int</code> 的属性，每次传递都会对这三个属性进行拷贝，如果可以也可以考虑传递 <code>slice</code> 的指针，指针只有一个 <code>int</code> 的大小。</p><p><strong> 对于不确定大小的数据只能用 <code>slice</code>，否则就要自己做扩容很麻烦， 对于确定大小的集合建议使用数组。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;array&lt;/code&gt; 和 &lt;code&gt;slice&lt;/code&gt; 看似相似，却有着极大的不同，但他们之间还有着千次万缕的联系 &lt;code&gt;slice&lt;/code&gt; 是引用类型、是 &lt;code&gt;array&lt;/code&gt; 的引用，相当于动态数组，&lt;br&gt;这些都是 &lt;code&gt;slice&lt;/code&gt; 的特性，但是 &lt;code&gt;slice&lt;/code&gt; 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 &lt;code&gt;slice&lt;/code&gt; 的情况下，怎样可以高效使用 &lt;code&gt;slice&lt;/code&gt;？&lt;br&gt;今天借助 &lt;code&gt;Go&lt;/code&gt; 的 &lt;code&gt;unsafe&lt;/code&gt; 包来探索 &lt;code&gt;array&lt;/code&gt; 和 &lt;code&gt;slice&lt;/code&gt; 的各种奥妙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="slice" scheme="https://blog.thinkeridea.com/tags/slice/"/>
    
      <category term="array" scheme="https://blog.thinkeridea.com/tags/array/"/>
    
      <category term="unsafe" scheme="https://blog.thinkeridea.com/tags/unsafe/"/>
    
  </entry>
  
  <entry>
    <title>【Go】一次读锁重入导致的死锁故障</title>
    <link href="https://blog.thinkeridea.com/201812/go/yi_ci_du_suo_chong_ru_dao_zhi_de_si_suo_gu_zhang.html"/>
    <id>https://blog.thinkeridea.com/201812/go/yi_ci_du_suo_chong_ru_dao_zhi_de_si_suo_gu_zhang.html</id>
    <published>2018-12-25T14:30:10.000Z</published>
    <updated>2019-01-12T14:47:24.523Z</updated>
    
    <content type="html"><![CDATA[<p>在两天前第一次遇到自己的程序出现死锁， 我一直非常的小心使用锁，了解死锁导致的各种可能性，<br>这次的经历让我未来会更加小心，下面来回顾一下死锁发生的过程与代码演进的过程吧。</p><h2 id="简述业务背景及代码演进过程"><a href="#简述业务背景及代码演进过程" class="headerlink" title="简述业务背景及代码演进过程"></a>简述业务背景及代码演进过程</h2><p>我的程序中有一块缓存，数据会组织好放到内存中，会根据数据源（MySQL）更新而刷新缓存，是读多写少的应用场景。<br>内存中有一个很大数据列表，缓存模块会按数据维度进行分组，每次访问根据维度查找到这个列表里面的所有数据。<br>业务模块拿到数据后会根据业务需要再做一次筛选，选出N个符合条件的数据（具体多少个由业务模块的规则决定）。</p><a id="more"></a><p>以下是简化的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">data []<span class="keyword">int</span> <span class="comment">// 实际数据比这个复杂很多有很多维度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">c.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数据， 简单写一个筛选过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.data &#123;</span><br><span class="line"><span class="keyword">if</span> c.data[i] &gt; <span class="number">10</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, c.data[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回的数据会很多，可实际业务需要的数据只有几个而已，那做一个优化吧，利用 <code>go</code> 的 <code>chan</code> 实现一个迭代生成器，每次只返回一个数据，业务端找到需要的数据后立即终止。</p><p>调整后的方法大致像下面这样:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">data []<span class="keyword">int</span> <span class="comment">// 实际数据比这个复杂很多有很多维度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(next <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数据， 简单写一个筛选过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.data &#123;</span><br><span class="line"><span class="keyword">if</span> c.data[i] &gt; <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">ch &lt;- i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := &lt;-next; !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用端的代码类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">c := Cache&#123;&#125;</span><br><span class="line">next := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.Get(next) &#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, i)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(next)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调整后查看程序的内存分配显著降低，而且平安无事在生产环境运行了半个月^_^，当然截止当前还不会出现死锁的情况。<br>有一天业务调整了，在 <code>cache</code> 模块有另外一个方法，公用这个锁（实际我缓存模块为了统一，都使用一个锁，方便管理），下面的代码也写到这个 <code>cache</code> 组件里面。</p><p>以下代码只增加了改变的部分，<code>....</code> 保持原来的代码不变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">....</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">XX</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">c.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>  i &gt;c.x &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>添加一个方法怎么就导致死锁了呢，主要是调用端的业务代码也发生变化了，更改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">c := Cache&#123;&#125;</span><br><span class="line">next := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.Get(next) &#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, i)</span><br><span class="line">    <span class="keyword">if</span> c.XX(i) != i  &#123; <span class="comment">// 在这里调用了缓存模块的另一个方法</span></span><br><span class="line">        <span class="built_in">close</span>(next)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码上线存活了5天就挂了，实际是当时业务订单需求很少，只是有很多流量请求，并没有频繁访问这个方法，否者会在极短的时间导致死锁，<br>通过这块简化的代码，也很难分析出会导致死锁，真实的业务代码很多，而且调用关系比较复杂，我们通过代码审核并没有发现任何问题。</p><h2 id="事故现场分析排查问题"><a href="#事故现场分析排查问题" class="headerlink" title="事故现场分析排查问题"></a>事故现场分析排查问题</h2><p>上线5天后突然接到服务无法响应的报警，事故发生立即查看了 <code>grafana</code> 的监控数据，发现在极段时间内服务器资源消耗极速增长，然后就立即没有响应了</p><p><img src="/assets/image/20181225/20181219-011353.jpg" alt=""></p><p>通过业务监控发现服务在极端的时间打开近10万个 <code>goroutine</code> 之后持续了很长一段时间，<br><code>cpu</code> 占用和 <code>gc</code> 都很正常， 内存方面可以看出短时间内分配了很多内存，但是没有被释放，<code>gc</code> 没法回收说明一直被占用，</p><p>看到这里我心里在想可能是有个 <code>goroutine</code> 因为什么原因导致无法结束造成的事故吧，<br>然后我再往下看（实际页面是在需要滚动屏幕，第一屏只显示了上面6个模块），发现 open files 和 <code>goroutine</code> 的情况一致，并且之后的数据突然中断，<br>中断是因为服务无法影响，也就无法采集服务的信息了。</p><p><img src="/assets/image/20181225/openfd.jpg" alt=""></p><p><code>goroutine</code> 并不会占用 open files，一个http服务导致这种情况大概只能是网络连接过多，我们遭受攻击了吗……<br>显然是没有的不然cpu不能很正常，那就是有可能请求无法响应，什么原因导致呢？</p><p>使用 <code>lsof -n | grep dsp | wc -l</code> 命令去服务器查找服务打开文件数，确实在六万五千多，<br>通过 <code>cat /proc/30717/limits</code> 发现 <code>Max open files            65535                65535                files</code>，<br>配置的最大打开文件数只有 65535，使用 <code>lsof -n | grep dsp |grep TCP | wc -l</code> 发现数据和之前接近，只小了几个，那是日志文件占用的。</p><p>查看日志发现大量 <code>http: Accept error: accept tcp 172.17.191.231:8090: accept4: too many open files; retrying in 1s</code> 错误。</p><p>这些数据帮助我快速定位确实是有请求发送到服务器，服务器无法响应导致短时间内占用很多文件打开数，导致系统限制无法建立新的连接。<br>这里要说一下，即使客户端断开连接了，服务器连接还是没有办法关闭，因为 <code>goroutine</code> 没有办法关闭， 除非自己退出。</p><p>找到原因了，服务没法响应，没法通过现场查找问题了，先重新启动一下服务，恢复业务在查找代码问题。</p><p>接下来就是查找代码问题了，期间又出现了一次故障，立即重启服务，恢复业务。</p><h2 id="分析解决问题"><a href="#分析解决问题" class="headerlink" title="分析解决问题"></a>分析解决问题</h2><p>通过几个小时分析代码逻辑，终于有了进展，发现上面的示例代码逻辑块导致读锁重入，存在死锁风险，这种死锁的碰撞概率非常低，<br>之前说过我们的缓存是读多写少的场景，如果只是读取数据，上面的代码不会有任何问题，我们一天刷新缓存的次数也不过百余次而已。</p><p>看一下究竟发生了什么导致的死锁吧：</p><ul><li>程序执行 <code>cache.Get</code> 获取一个 <code>chan</code>, 在 <code>cache.Get</code> 里面有一个 <code>goroutine</code> 读取数据只有加了读写锁，只有 <code>goroutine</code> 关闭才会释放</li><li><code>for i := range c.Get(next) {</code> 遍历 <code>chan</code> 时 <code>goroutine</code> 不会结束，也就说读锁没有被释放</li><li>遍历时执行了 <code>c.XX(i)</code> 方法，在该方面里面也加了读锁， 形成了读锁重入的场景，但是该放执行周期很短，执行完就会马上释放</li></ul><p>好吧，这样的流程并没有形成死锁，什么情况下导致的死锁呢，接着看一下一个场景：</p><ul><li>程序执行 <code>cache.Get</code> 获取一个 <code>chan</code>, 在 <code>cache.Get</code> 里面有一个 <code>goroutine</code> 读取数据只有加了读写锁，只有 <code>goroutine</code> 关闭才会释放</li><li><code>for i := range c.Get(next) {</code> 遍历 <code>chan</code> 时 <code>goroutine</code> 不会结束，也就说读锁没有被释放</li><li>数据发生了改变，触发了缓存刷新，申请独占锁（写锁），等待所有读锁释放</li><li>遍历时执行 <code>c.XX(i)</code> 方法，该方法申请读锁，因为写锁在等待，所以任何读锁都将等待写锁释放后才能添加成功</li><li>for 循环被阻塞， <code>cache.Get</code> 里面的 <code>goroutine</code> 无法退出，无法释放读锁</li><li>写锁等待所有读锁释放</li><li><code>c.XX(i)</code> 等待写锁释放</li><li>….</li></ul><p>重点看第三步，这里是关键，因为在两个嵌套的读锁中间申请写锁，导致死锁发生，找到原因修复起来很简单的，</p><p>调整 <code>cache.Get</code> 加锁的方法，把 <code>c.data</code> 赋值给一个临时变量 <code>data</code>, 在这段代码前后加锁和释放锁，锁的代码块更小，时间更短</p><p><code>c.data</code> 单独拷贝是安全的，那怕是指针数据，因为每次刷新缓存都会给 <code>c.data</code> 重新赋值，分配新的内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">data []<span class="keyword">int</span> <span class="comment">// 实际数据比这个复杂很多有很多维度</span></span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">XX</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    c.lock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>  i &gt;c.x &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(next <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">c.lock.RLock()</span><br><span class="line">data := c.data</span><br><span class="line">c.lock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数据， 简单写一个筛选过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] &gt; <span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">ch &lt;- i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := &lt;-next; !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复之后的业务状态：</p><p><img src="/assets/image/20181225/20181219-011418.jpg" alt=""></p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>用程序复现一下上面的场景可以吗，好像有点难，我写了一个简单的复现代码，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = sync.RWMutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.RLock() <span class="comment">// 读锁1</span></span><br><span class="line"><span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">fmt.Println(<span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="number">2</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">fmt.Println(<span class="number">3</span>)</span><br><span class="line">b()</span><br><span class="line">fmt.Println(<span class="number">4</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">5</span>)</span><br><span class="line">&lt;-c</span><br><span class="line">fmt.Println(<span class="number">6</span>)</span><br><span class="line">l.Lock()</span><br><span class="line">fmt.Println(<span class="number">7</span>)</span><br><span class="line">fmt.Println(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">defer</span> l.Unlock()</span><br><span class="line">fmt.Println(<span class="number">9</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">10</span>)</span><br><span class="line">l.RLock() <span class="comment">// 读锁2</span></span><br><span class="line">fmt.Println(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">fmt.Println(<span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出(受 <code>goroutine</code> 运行时影响在输出数字3之前会有些许差异)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>分析一下这个运行流程吧:</p><ul><li>首先加上读锁1，就是 <code>fmt.Println(1)</code> 之前， 状态加读锁1</li><li>另外一个 <code>goroutine</code> 启动，<code>fmt.Println(5)</code>， 状态加读锁1</li><li>发送数据 <code>c &lt;- 1</code> ， 状态加读锁1</li><li>接受到数据 <code>&lt;-c</code> <code>fmt.Println(6)</code>， 状态加读锁1</li><li>输出 2 <code>fmt.Println(2)</code>， 状态加读锁1</li><li>暂停当前 <code>goroutine</code> <code>runtime.Gosched()</code> ， 状态加读锁1</li><li>申请写锁 <code>l.Lock()</code>， 等待读锁1释放， 状态加读锁1、写锁等待</li><li>切换 <code>goroutine</code> 执行 <code>fmt.Println(3)</code> 与 <code>b()</code>， 状态加读锁1、写锁等待</li><li>输出10 <code>fmt.Println(10)</code>， 申请读锁2，等待写锁释放， 状态加读锁1、写锁等待、读锁2等待</li><li>支持程序永久阻塞……</li></ul><h2 id="分析读写锁实现"><a href="#分析读写锁实现" class="headerlink" title="分析读写锁实现"></a>分析读写锁实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请写锁时会在 <code>rw.readerCount</code> 读数量变量上自增加 1，如果结果小于 0，当前读锁进入修改等待读锁唤醒信号，<br>单独看着一个方法会比较懵，为啥读的数量会小于0呢，接着看写锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">rw.w.Lock()</span><br><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// Wait for active readers.</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请写锁时会先加上互斥锁，也就是有其它写的客户端的话会等待写锁释放才能加上，具体实现看互斥锁的代码，<br>然后在 <code>rw.readerCount</code> 上自增一个极大的负数 <code>1 &lt;&lt; 30</code> ， 读写锁这里也就限制了我们的同时读的进程不能超过这个值。<br>然后在结果上加上 <code>rwmutexMaxReaders</code> 也就是 <code>atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</code> 得到实际读客户端的数量<br>如果读的客户端不等于0，就在 <code>rw.readerWait</code> 自增读客户端的数量，之后陷入睡眠，等待 <code>rw.writerSem</code> 唤醒。</p><p>分析了这两段代码我们就能明白，写锁等待或者添加时，读锁没法添加上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A writer is pending.</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放读锁，先在 <code>rw.readerCount</code> 减 1，然后检查读客户端是否小于0，如果小于0说明有写锁在等待，<br>在 <code>rw.readerWait</code> 上减1，这个变量记录的是写等待读客户端的数量，如果没有需要等待的读客户端了，就通知 <code>rw.writerSem</code> 唤醒写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">rw.w.Unlock()</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁在释放时会给 <code>rw.readerCount</code> 自增 <code>rwmutexMaxReaders</code> 还原真实读客户端数量。<br><code>for i := 0; i &lt; int(r); i++ {</code> 用来唤醒所有的读客户端，因为在写锁的时候，申请读锁的客户端会被计数，但是都会陷入睡眠状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以前特别强调过读锁重入导致死锁的问题，而且这个问题非常难在业务代码里面复现，触发几率很低，<br>编译和运行时都无法检测这种情况，所以千万不能陷入读锁重入的嵌套使用的情况，否者问题非常难以排查。</p><p>关于加锁的几个小经验：</p><ul><li>运行时离开当前逻辑就释放锁。</li><li>锁的粒度越小越好，加锁后尽快释放锁。</li><li>尽量不用 <code>defer</code> 释放锁。</li><li>读锁不要嵌套。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在两天前第一次遇到自己的程序出现死锁， 我一直非常的小心使用锁，了解死锁导致的各种可能性，&lt;br&gt;这次的经历让我未来会更加小心，下面来回顾一下死锁发生的过程与代码演进的过程吧。&lt;/p&gt;
&lt;h2 id=&quot;简述业务背景及代码演进过程&quot;&gt;&lt;a href=&quot;#简述业务背景及代码演进过程&quot; class=&quot;headerlink&quot; title=&quot;简述业务背景及代码演进过程&quot;&gt;&lt;/a&gt;简述业务背景及代码演进过程&lt;/h2&gt;&lt;p&gt;我的程序中有一块缓存，数据会组织好放到内存中，会根据数据源（MySQL）更新而刷新缓存，是读多写少的应用场景。&lt;br&gt;内存中有一个很大数据列表，缓存模块会按数据维度进行分组，每次访问根据维度查找到这个列表里面的所有数据。&lt;br&gt;业务模块拿到数据后会根据业务需要再做一次筛选，选出N个符合条件的数据（具体多少个由业务模块的规则决定）。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="https://blog.thinkeridea.com/categories/go/"/>
    
    
      <category term="读写锁" scheme="https://blog.thinkeridea.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
      <category term="死锁" scheme="https://blog.thinkeridea.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
</feed>
